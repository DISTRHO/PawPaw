diff --git a/configure.in b/configure.in
index f325bb1..178588f 100644
--- a/configure.in
+++ b/configure.in
@@ -134,7 +134,7 @@ if test "x$with_oss" != "xno"; then
 fi
 have_jack=no
 if test "x$with_jack" != "xno"; then
-    PKG_CHECK_MODULES(JACK, jack, have_jack=yes, have_jack=no)
+    have_jack=yes
 fi
 
 
diff --git a/src/hostapi/jack/JackBridge.c b/src/hostapi/jack/JackBridge.c
new file mode 100644
index 0000000..facfb53
--- /dev/null
+++ b/src/hostapi/jack/JackBridge.c
@@ -0,0 +1,1826 @@
+/*
+ * JackBridge for DPF
+ * Copyright (C) 2013-2022 Filipe Coelho <falktx@falktx.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any purpose with
+ * or without fee is hereby granted, provided that the above copyright notice and this
+ * permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "JackBridge.h"
+
+#ifdef _WIN32
+# define JACKSYM_API __cdecl
+#else
+# define JACKSYM_API
+#endif
+
+#define __USE_GNU
+#include <dlfcn.h>
+#include <errno.h>
+typedef void* lib_t;
+
+// -----------------------------------------------------------------------------
+
+typedef void (JACKSYM_API *JackSymLatencyCallback)(jack_latency_callback_mode_t, void*);
+typedef int  (JACKSYM_API *JackSymProcessCallback)(jack_nframes_t, void*);
+typedef void (JACKSYM_API *JackSymThreadInitCallback)(void*);
+typedef int  (JACKSYM_API *JackSymGraphOrderCallback)(void*);
+typedef int  (JACKSYM_API *JackSymXRunCallback)(void*);
+typedef int  (JACKSYM_API *JackSymBufferSizeCallback)(jack_nframes_t, void*);
+typedef int  (JACKSYM_API *JackSymSampleRateCallback)(jack_nframes_t, void*);
+typedef void (JACKSYM_API *JackSymPortRegistrationCallback)(jack_port_id_t, int, void*);
+typedef void (JACKSYM_API *JackSymClientRegistrationCallback)(const char*, int, void*);
+typedef void (JACKSYM_API *JackSymPortConnectCallback)(jack_port_id_t, jack_port_id_t, int, void*);
+typedef void (JACKSYM_API *JackSymPortRenameCallback)(jack_port_id_t, const char*, const char*, void*);
+typedef void (JACKSYM_API *JackSymFreewheelCallback)(int, void*);
+typedef void (JACKSYM_API *JackSymShutdownCallback)(void*);
+typedef void (JACKSYM_API *JackSymInfoShutdownCallback)(jack_status_t, const char*, void*);
+typedef int  (JACKSYM_API *JackSymSyncCallback)(jack_transport_state_t, jack_position_t*, void*);
+typedef void (JACKSYM_API *JackSymTimebaseCallback)(jack_transport_state_t, jack_nframes_t, jack_position_t*, int, void*);
+typedef void (JACKSYM_API *JackSymSessionCallback)(jack_session_event_t*, void*);
+typedef void (JACKSYM_API *JackSymPropertyChangeCallback)(jack_uuid_t, const char*, jack_property_change_t, void*);
+typedef void* (JACKSYM_API *JackSymThreadCallback)(void*);
+
+typedef void        (JACKSYM_API *jacksym_get_version)(int*, int*, int*, int*);
+typedef const char* (JACKSYM_API *jacksym_get_version_string)(void);
+
+typedef jack_client_t* (JACKSYM_API *jacksym_client_open)(const char*, jack_options_t, jack_status_t*, ...);
+typedef int            (JACKSYM_API *jacksym_client_close)(jack_client_t*);
+
+typedef int   (JACKSYM_API *jacksym_client_name_size)(void);
+typedef char* (JACKSYM_API *jacksym_get_client_name)(jack_client_t*);
+
+typedef char* (JACKSYM_API *jacksym_client_get_uuid)(jack_client_t*);
+typedef char* (JACKSYM_API *jacksym_get_uuid_for_client_name)(jack_client_t*, const char*);
+typedef char* (JACKSYM_API *jacksym_get_client_name_by_uuid)(jack_client_t*, const char*);
+
+typedef int  (JACKBRIDGE_API *jacksym_uuid_parse)(const char*, jack_uuid_t*);
+typedef void (JACKBRIDGE_API *jacksym_uuid_unparse)(jack_uuid_t, char buf[JACK_UUID_STRING_SIZE]);
+
+typedef int (JACKSYM_API *jacksym_activate)(jack_client_t*);
+typedef int (JACKSYM_API *jacksym_deactivate)(jack_client_t*);
+typedef int (JACKSYM_API *jacksym_is_realtime)(jack_client_t*);
+
+typedef int  (JACKSYM_API *jacksym_set_thread_init_callback)(jack_client_t*, JackSymThreadInitCallback, void*);
+typedef void (JACKSYM_API *jacksym_on_shutdown)(jack_client_t*, JackSymShutdownCallback, void*);
+typedef void (JACKSYM_API *jacksym_on_info_shutdown)(jack_client_t*, JackSymInfoShutdownCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_process_callback)(jack_client_t*, JackSymProcessCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_freewheel_callback)(jack_client_t*, JackSymFreewheelCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_buffer_size_callback)(jack_client_t*, JackSymBufferSizeCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_sample_rate_callback)(jack_client_t*, JackSymSampleRateCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_client_registration_callback)(jack_client_t*, JackSymClientRegistrationCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_port_registration_callback)(jack_client_t*, JackSymPortRegistrationCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_port_rename_callback)(jack_client_t*, JackSymPortRenameCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_port_connect_callback)(jack_client_t*, JackSymPortConnectCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_graph_order_callback)(jack_client_t*, JackSymGraphOrderCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_xrun_callback)(jack_client_t*, JackSymXRunCallback, void*);
+typedef int  (JACKSYM_API *jacksym_set_latency_callback)(jack_client_t*, JackSymLatencyCallback, void*);
+
+typedef int (JACKSYM_API *jacksym_set_freewheel)(jack_client_t*, int);
+typedef int (JACKSYM_API *jacksym_set_buffer_size)(jack_client_t*, jack_nframes_t);
+
+typedef jack_nframes_t (JACKSYM_API *jacksym_get_sample_rate)(jack_client_t*);
+typedef jack_nframes_t (JACKSYM_API *jacksym_get_buffer_size)(jack_client_t*);
+typedef float          (JACKSYM_API *jacksym_cpu_load)(jack_client_t*);
+
+typedef jack_port_t* (JACKSYM_API *jacksym_port_register)(jack_client_t*, const char*, const char*, ulong, ulong);
+typedef int          (JACKSYM_API *jacksym_port_unregister)(jack_client_t*, jack_port_t*);
+typedef void*        (JACKSYM_API *jacksym_port_get_buffer)(jack_port_t*, jack_nframes_t);
+
+typedef const char*  (JACKSYM_API *jacksym_port_name)(const jack_port_t*);
+typedef jack_uuid_t  (JACKSYM_API *jacksym_port_uuid)(const jack_port_t*);
+typedef const char*  (JACKSYM_API *jacksym_port_short_name)(const jack_port_t*);
+typedef int          (JACKSYM_API *jacksym_port_flags)(const jack_port_t*);
+typedef const char*  (JACKSYM_API *jacksym_port_type)(const jack_port_t*);
+typedef int          (JACKSYM_API *jacksym_port_is_mine)(const jack_client_t*, const jack_port_t*);
+typedef int          (JACKSYM_API *jacksym_port_connected)(const jack_port_t*);
+typedef int          (JACKSYM_API *jacksym_port_connected_to)(const jack_port_t*, const char*);
+typedef const char** (JACKSYM_API *jacksym_port_get_connections)(const jack_port_t*);
+typedef const char** (JACKSYM_API *jacksym_port_get_all_connections)(const jack_client_t*, const jack_port_t*);
+
+typedef int (JACKSYM_API *jacksym_port_rename)(jack_client_t*, jack_port_t*, const char*);
+typedef int (JACKSYM_API *jacksym_port_set_name)(jack_port_t*, const char*);
+typedef int (JACKSYM_API *jacksym_port_set_alias)(jack_port_t*, const char*);
+typedef int (JACKSYM_API *jacksym_port_unset_alias)(jack_port_t*, const char*);
+typedef int (JACKSYM_API *jacksym_port_get_aliases)(const jack_port_t*, char* const aliases[2]);
+
+typedef int (JACKSYM_API *jacksym_port_request_monitor)(jack_port_t*, int);
+typedef int (JACKSYM_API *jacksym_port_request_monitor_by_name)(jack_client_t*, const char*, int);
+typedef int (JACKSYM_API *jacksym_port_ensure_monitor)(jack_port_t*, int);
+typedef int (JACKSYM_API *jacksym_port_monitoring_input)(jack_port_t*);
+
+typedef int (JACKSYM_API *jacksym_connect)(jack_client_t*, const char*, const char*);
+typedef int (JACKSYM_API *jacksym_disconnect)(jack_client_t*, const char*, const char*);
+typedef int (JACKSYM_API *jacksym_port_disconnect)(jack_client_t*, jack_port_t*);
+
+typedef int    (JACKSYM_API *jacksym_port_name_size)(void);
+typedef int    (JACKSYM_API *jacksym_port_type_size)(void);
+typedef size_t (JACKSYM_API *jacksym_port_type_get_buffer_size)(jack_client_t*, const char*);
+
+typedef void (JACKSYM_API *jacksym_port_get_latency_range)(jack_port_t*, jack_latency_callback_mode_t, jack_latency_range_t*);
+typedef void (JACKSYM_API *jacksym_port_set_latency_range)(jack_port_t*, jack_latency_callback_mode_t, jack_latency_range_t*);
+typedef int  (JACKSYM_API *jacksym_recompute_total_latencies)(jack_client_t*);
+
+typedef const char** (JACKSYM_API *jacksym_get_ports)(jack_client_t*, const char*, const char*, ulong);
+typedef jack_port_t* (JACKSYM_API *jacksym_port_by_name)(jack_client_t*, const char*);
+typedef jack_port_t* (JACKSYM_API *jacksym_port_by_id)(jack_client_t*, jack_port_id_t);
+
+typedef void (JACKSYM_API *jacksym_free)(void*);
+
+typedef uint32_t (JACKSYM_API *jacksym_midi_get_event_count)(void*);
+typedef int      (JACKSYM_API *jacksym_midi_event_get)(jack_midi_event_t*, void*, uint32_t);
+typedef void     (JACKSYM_API *jacksym_midi_clear_buffer)(void*);
+typedef int      (JACKSYM_API *jacksym_midi_event_write)(void*, jack_nframes_t, const jack_midi_data_t*, size_t);
+typedef jack_midi_data_t* (JACKSYM_API *jacksym_midi_event_reserve)(void*, jack_nframes_t, size_t);
+
+typedef int (JACKSYM_API *jacksym_release_timebase)(jack_client_t*);
+typedef int (JACKSYM_API *jacksym_set_sync_callback)(jack_client_t*, JackSymSyncCallback, void*);
+typedef int (JACKSYM_API *jacksym_set_sync_timeout)(jack_client_t*, jack_time_t);
+typedef int (JACKSYM_API *jacksym_set_timebase_callback)(jack_client_t*, int, JackSymTimebaseCallback, void*);
+typedef int (JACKSYM_API *jacksym_transport_locate)(jack_client_t*, jack_nframes_t);
+
+typedef jack_transport_state_t (JACKSYM_API *jacksym_transport_query)(const jack_client_t*, jack_position_t*);
+typedef jack_nframes_t         (JACKSYM_API *jacksym_get_current_transport_frame)(const jack_client_t*);
+
+typedef int  (JACKSYM_API *jacksym_transport_reposition)(jack_client_t*, const jack_position_t*);
+typedef void (JACKSYM_API *jacksym_transport_start)(jack_client_t*);
+typedef void (JACKSYM_API *jacksym_transport_stop)(jack_client_t*);
+
+typedef int  (JACKSYM_API *jacksym_set_property)(jack_client_t*, jack_uuid_t, const char*, const char*, const char*);
+typedef int  (JACKSYM_API *jacksym_get_property)(jack_uuid_t, const char*, char**, char**);
+typedef void (JACKSYM_API *jacksym_free_description)(jack_description_t*, int);
+typedef int  (JACKSYM_API *jacksym_get_properties)(jack_uuid_t, jack_description_t*);
+typedef int  (JACKSYM_API *jacksym_get_all_properties)(jack_description_t**);
+typedef int  (JACKSYM_API *jacksym_remove_property)(jack_client_t*, jack_uuid_t, const char*);
+typedef int  (JACKSYM_API *jacksym_remove_properties)(jack_client_t*, jack_uuid_t);
+typedef int  (JACKSYM_API *jacksym_remove_all_properties)(jack_client_t*);
+typedef int  (JACKSYM_API *jacksym_set_property_change_callback)(jack_client_t*, JackSymPropertyChangeCallback, void*);
+
+typedef bool           (JACKSYM_API *jacksym_set_process_thread)(jack_client_t*, JackSymThreadCallback callback, void*);
+typedef jack_nframes_t (JACKSYM_API *jacksym_cycle_wait)(jack_client_t*);
+typedef void           (JACKSYM_API *jacksym_cycle_signal)(jack_client_t*, int);
+
+typedef jack_nframes_t (JACKSYM_API *jacksym_port_get_latency)(jack_port_t*);
+typedef jack_nframes_t (JACKSYM_API *jacksym_frame_time)(const jack_client_t*);
+
+// -----------------------------------------------------------------------------
+
+typedef struct JackBridge {
+    lib_t lib;
+
+    jacksym_get_version get_version_ptr;
+    jacksym_get_version_string get_version_string_ptr;
+
+    jacksym_client_open client_open_ptr;
+    jacksym_client_close client_close_ptr;
+
+    jacksym_client_name_size client_name_size_ptr;
+    jacksym_get_client_name get_client_name_ptr;
+
+    jacksym_client_get_uuid client_get_uuid_ptr;
+    jacksym_get_uuid_for_client_name get_uuid_for_client_name_ptr;
+    jacksym_get_client_name_by_uuid get_client_name_by_uuid_ptr;
+
+    jacksym_uuid_parse uuid_parse_ptr;
+    jacksym_uuid_unparse uuid_unparse_ptr;
+
+    jacksym_activate activate_ptr;
+    jacksym_deactivate deactivate_ptr;
+    jacksym_is_realtime is_realtime_ptr;
+
+    jacksym_set_thread_init_callback set_thread_init_callback_ptr;
+    jacksym_on_shutdown on_shutdown_ptr;
+    jacksym_on_info_shutdown on_info_shutdown_ptr;
+    jacksym_set_process_callback set_process_callback_ptr;
+    jacksym_set_freewheel_callback set_freewheel_callback_ptr;
+    jacksym_set_buffer_size_callback set_buffer_size_callback_ptr;
+    jacksym_set_sample_rate_callback set_sample_rate_callback_ptr;
+    jacksym_set_client_registration_callback set_client_registration_callback_ptr;
+    jacksym_set_port_registration_callback set_port_registration_callback_ptr;
+    jacksym_set_port_rename_callback set_port_rename_callback_ptr;
+    jacksym_set_port_connect_callback set_port_connect_callback_ptr;
+    jacksym_set_graph_order_callback set_graph_order_callback_ptr;
+    jacksym_set_xrun_callback set_xrun_callback_ptr;
+    jacksym_set_latency_callback set_latency_callback_ptr;
+
+    jacksym_set_freewheel set_freewheel_ptr;
+    jacksym_set_buffer_size set_buffer_size_ptr;
+
+    jacksym_get_sample_rate get_sample_rate_ptr;
+    jacksym_get_buffer_size get_buffer_size_ptr;
+    jacksym_cpu_load cpu_load_ptr;
+
+    jacksym_port_register port_register_ptr;
+    jacksym_port_unregister port_unregister_ptr;
+    jacksym_port_get_buffer port_get_buffer_ptr;
+
+    jacksym_port_name port_name_ptr;
+    jacksym_port_uuid port_uuid_ptr;
+    jacksym_port_short_name port_short_name_ptr;
+    jacksym_port_flags port_flags_ptr;
+    jacksym_port_type port_type_ptr;
+    jacksym_port_is_mine port_is_mine_ptr;
+    jacksym_port_connected port_connected_ptr;
+    jacksym_port_connected_to port_connected_to_ptr;
+    jacksym_port_get_connections port_get_connections_ptr;
+    jacksym_port_get_all_connections port_get_all_connections_ptr;
+
+    jacksym_port_rename port_rename_ptr;
+    jacksym_port_set_name port_set_name_ptr;
+    jacksym_port_set_alias port_set_alias_ptr;
+    jacksym_port_unset_alias port_unset_alias_ptr;
+    jacksym_port_get_aliases port_get_aliases_ptr;
+
+    jacksym_port_request_monitor port_request_monitor_ptr;
+    jacksym_port_request_monitor_by_name port_request_monitor_by_name_ptr;
+    jacksym_port_ensure_monitor port_ensure_monitor_ptr;
+    jacksym_port_monitoring_input port_monitoring_input_ptr;
+
+    jacksym_connect connect_ptr;
+    jacksym_disconnect disconnect_ptr;
+    jacksym_port_disconnect port_disconnect_ptr;
+
+    jacksym_port_name_size port_name_size_ptr;
+    jacksym_port_type_size port_type_size_ptr;
+    jacksym_port_type_get_buffer_size port_type_get_buffer_size_ptr;
+
+    jacksym_port_get_latency_range port_get_latency_range_ptr;
+    jacksym_port_set_latency_range port_set_latency_range_ptr;
+    jacksym_recompute_total_latencies recompute_total_latencies_ptr;
+
+    jacksym_get_ports get_ports_ptr;
+    jacksym_port_by_name port_by_name_ptr;
+    jacksym_port_by_id port_by_id_ptr;
+
+    jacksym_free free_ptr;
+
+    jacksym_midi_get_event_count midi_get_event_count_ptr;
+    jacksym_midi_event_get midi_event_get_ptr;
+    jacksym_midi_clear_buffer midi_clear_buffer_ptr;
+    jacksym_midi_event_write midi_event_write_ptr;
+    jacksym_midi_event_reserve midi_event_reserve_ptr;
+
+    jacksym_release_timebase release_timebase_ptr;
+    jacksym_set_sync_callback set_sync_callback_ptr;
+    jacksym_set_sync_timeout set_sync_timeout_ptr;
+    jacksym_set_timebase_callback set_timebase_callback_ptr;
+    jacksym_transport_locate transport_locate_ptr;
+
+    jacksym_transport_query transport_query_ptr;
+    jacksym_get_current_transport_frame get_current_transport_frame_ptr;
+
+    jacksym_transport_reposition transport_reposition_ptr;
+    jacksym_transport_start transport_start_ptr;
+    jacksym_transport_stop transport_stop_ptr;
+
+    jacksym_set_property set_property_ptr;
+    jacksym_get_property get_property_ptr;
+    jacksym_free_description free_description_ptr;
+    jacksym_get_properties get_properties_ptr;
+    jacksym_get_all_properties get_all_properties_ptr;
+    jacksym_remove_property remove_property_ptr;
+    jacksym_remove_properties remove_properties_ptr;
+    jacksym_remove_all_properties remove_all_properties_ptr;
+    jacksym_set_property_change_callback set_property_change_callback_ptr;
+
+    jacksym_set_process_thread set_process_thread_ptr;
+    jacksym_cycle_wait cycle_wait_ptr;
+    jacksym_cycle_signal cycle_signal_ptr;
+
+    jacksym_port_get_latency port_get_latency_ptr;
+    jacksym_frame_time frame_time_ptr;
+} JackBridge;
+
+static void jackbridge_init(JackBridge* const bridge)
+{
+    memset(bridge, 0, sizeof(*bridge));
+
+#if !(defined(JACKBRIDGE_DUMMY) || defined(JACKBRIDGE_DIRECT))
+   #if defined(__APPLE__)
+    const char* const filename = "libjack.dylib";
+    void* const lib = dlopen(filename, RTLD_NOW|RTLD_LOCAL);
+   #elif defined(_WIN64)
+    const char* const filename = "libjack64.dll";
+    void* const lib = LoadLibraryA(filename);
+   #elif defined(_WIN32)
+    const char* const filename = "libjack.dll";
+    void* const lib = LoadLibraryA(filename);
+   #else
+    const char* const filenameEnv = getenv("JACKBRIDGE_FILENAME");
+    const char* const filename = filenameEnv != NULL ? filenameEnv : "libjack.so.0";
+    void* const lib = filenameEnv != NULL
+                    ? dlmopen(LM_ID_NEWLM, filename, RTLD_NOW|RTLD_LOCAL)
+                    : dlopen(filename, RTLD_NOW|RTLD_LOCAL);
+   #endif
+
+    if (lib == NULL)
+    {
+        fprintf(stderr, "Failed to load JACK DLL, reason:\n%s\n", dlerror());
+        return;
+    }
+    else
+    {
+        fprintf(stdout, "%s loaded successfully!\n", filename);
+    }
+
+    #define JOIN(a, b) a ## b
+    #define LIB_SYMBOL(NAME) bridge->JOIN(NAME, _ptr) = (jacksym_##NAME)dlsym(lib, "jack_" #NAME);
+
+    LIB_SYMBOL(get_version)
+    LIB_SYMBOL(get_version_string)
+
+    LIB_SYMBOL(client_open)
+    LIB_SYMBOL(client_close)
+
+    LIB_SYMBOL(client_name_size)
+    LIB_SYMBOL(get_client_name)
+
+    LIB_SYMBOL(client_get_uuid)
+    LIB_SYMBOL(get_uuid_for_client_name)
+    LIB_SYMBOL(get_client_name_by_uuid)
+
+    LIB_SYMBOL(uuid_parse)
+    LIB_SYMBOL(uuid_unparse)
+
+    LIB_SYMBOL(activate)
+    LIB_SYMBOL(deactivate)
+    LIB_SYMBOL(is_realtime)
+
+    LIB_SYMBOL(set_thread_init_callback)
+    LIB_SYMBOL(on_shutdown)
+    LIB_SYMBOL(on_info_shutdown)
+    LIB_SYMBOL(set_process_callback)
+    LIB_SYMBOL(set_freewheel_callback)
+    LIB_SYMBOL(set_buffer_size_callback)
+    LIB_SYMBOL(set_sample_rate_callback)
+    LIB_SYMBOL(set_client_registration_callback)
+    LIB_SYMBOL(set_port_registration_callback)
+    LIB_SYMBOL(set_port_rename_callback)
+    LIB_SYMBOL(set_port_connect_callback)
+    LIB_SYMBOL(set_graph_order_callback)
+    LIB_SYMBOL(set_xrun_callback)
+    LIB_SYMBOL(set_latency_callback)
+
+    LIB_SYMBOL(set_freewheel)
+    LIB_SYMBOL(set_buffer_size)
+
+    LIB_SYMBOL(get_sample_rate)
+    LIB_SYMBOL(get_buffer_size)
+    LIB_SYMBOL(cpu_load)
+
+    LIB_SYMBOL(port_register)
+    LIB_SYMBOL(port_unregister)
+    LIB_SYMBOL(port_get_buffer)
+
+    LIB_SYMBOL(port_name)
+    LIB_SYMBOL(port_uuid)
+    LIB_SYMBOL(port_short_name)
+    LIB_SYMBOL(port_flags)
+    LIB_SYMBOL(port_type)
+    LIB_SYMBOL(port_is_mine)
+    LIB_SYMBOL(port_connected)
+    LIB_SYMBOL(port_connected_to)
+    LIB_SYMBOL(port_get_connections)
+    LIB_SYMBOL(port_get_all_connections)
+
+    LIB_SYMBOL(port_rename)
+    LIB_SYMBOL(port_set_name)
+    LIB_SYMBOL(port_set_alias)
+    LIB_SYMBOL(port_unset_alias)
+    LIB_SYMBOL(port_get_aliases)
+
+    LIB_SYMBOL(port_request_monitor)
+    LIB_SYMBOL(port_request_monitor_by_name)
+    LIB_SYMBOL(port_ensure_monitor)
+    LIB_SYMBOL(port_monitoring_input)
+
+    LIB_SYMBOL(connect)
+    LIB_SYMBOL(disconnect)
+    LIB_SYMBOL(port_disconnect)
+
+    LIB_SYMBOL(port_name_size)
+    LIB_SYMBOL(port_type_size)
+    LIB_SYMBOL(port_type_get_buffer_size)
+
+    LIB_SYMBOL(port_get_latency_range)
+    LIB_SYMBOL(port_set_latency_range)
+    LIB_SYMBOL(recompute_total_latencies)
+
+    LIB_SYMBOL(get_ports)
+    LIB_SYMBOL(port_by_name)
+    LIB_SYMBOL(port_by_id)
+
+    LIB_SYMBOL(free)
+
+    LIB_SYMBOL(midi_get_event_count)
+    LIB_SYMBOL(midi_event_get)
+    LIB_SYMBOL(midi_clear_buffer)
+    LIB_SYMBOL(midi_event_write)
+    LIB_SYMBOL(midi_event_reserve)
+
+    LIB_SYMBOL(release_timebase)
+    LIB_SYMBOL(set_sync_callback)
+    LIB_SYMBOL(set_sync_timeout)
+    LIB_SYMBOL(set_timebase_callback)
+    LIB_SYMBOL(transport_locate)
+    LIB_SYMBOL(transport_query)
+    LIB_SYMBOL(get_current_transport_frame)
+    LIB_SYMBOL(transport_reposition)
+    LIB_SYMBOL(transport_start)
+    LIB_SYMBOL(transport_stop)
+
+    LIB_SYMBOL(set_property)
+    LIB_SYMBOL(get_property)
+    LIB_SYMBOL(free_description)
+    LIB_SYMBOL(get_properties)
+    LIB_SYMBOL(get_all_properties)
+    LIB_SYMBOL(remove_property)
+    LIB_SYMBOL(remove_properties)
+    LIB_SYMBOL(remove_all_properties)
+    LIB_SYMBOL(set_property_change_callback)
+
+    LIB_SYMBOL(set_process_thread)
+    LIB_SYMBOL(cycle_wait)
+    LIB_SYMBOL(cycle_signal)
+
+    LIB_SYMBOL(port_get_latency)
+    LIB_SYMBOL(frame_time)
+
+    #undef JOIN
+    #undef LIB_SYMBOL
+
+    bridge->lib = lib;
+#endif
+}
+
+static void jackbridge_destroy(JackBridge* const bridge)
+{
+    if (bridge->lib != NULL)
+    {
+        dlclose(bridge->lib);
+        bridge->lib = NULL;
+    }
+}
+
+static JackBridge* jackbridge_instance()
+{
+    static JackBridge bridge;
+    static bool init = false;
+    if (! init)
+    {
+        init = true;
+        jackbridge_init(&bridge);
+    }
+    return &bridge;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_is_ok()
+{
+#if defined(JACKBRIDGE_DUMMY)
+    return false;
+#elif defined(JACKBRIDGE_DIRECT)
+    return true;
+#else
+    return jackbridge_instance()->lib != NULL;
+#endif
+}
+
+// -----------------------------------------------------------------------------
+
+void jackbridge_get_version(int* major_ptr, int* minor_ptr, int* micro_ptr, int* proto_ptr)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_version(major_ptr, minor_ptr, micro_ptr, proto_ptr);
+#else
+    if (jackbridge_instance()->get_version_ptr != NULL)
+        return jackbridge_instance()->get_version_ptr(major_ptr, minor_ptr, micro_ptr, proto_ptr);
+#endif
+    if (major_ptr != NULL)
+        *major_ptr = 0;
+    if (minor_ptr != NULL)
+        *minor_ptr = 0;
+    if (micro_ptr != NULL)
+        *micro_ptr = 0;
+    if (proto_ptr != NULL)
+        *proto_ptr = 0;
+}
+
+const char* jackbridge_get_version_string()
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_version_string();
+#else
+    if (jackbridge_instance()->get_version_string_ptr != NULL)
+        return jackbridge_instance()->get_version_string_ptr();
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+jack_client_t* jackbridge_client_open(const char* client_name, uint32_t options, jack_status_t* status)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_client_open(client_name, (jack_options_t)options, status);
+#endif
+    if (jackbridge_instance()->client_open_ptr != NULL)
+        return jackbridge_instance()->client_open_ptr(client_name, (jack_options_t)options, status);
+    if (status != NULL)
+        *status = JackServerError;
+    return NULL;
+}
+
+bool jackbridge_client_close(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_client_close(client) == 0);
+#else
+    if (jackbridge_instance()->client_close_ptr != NULL)
+        return (jackbridge_instance()->client_close_ptr(client) == 0);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+int jackbridge_client_name_size()
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_client_name_size();
+#else
+    if (jackbridge_instance()->client_name_size_ptr != NULL)
+        return jackbridge_instance()->client_name_size_ptr();
+#endif
+    return 33;
+}
+
+const char* jackbridge_get_client_name(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_client_name(client);
+#else
+    if (jackbridge_instance()->get_client_name_ptr != NULL)
+        return jackbridge_instance()->get_client_name_ptr(client);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+char* jackbridge_client_get_uuid(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_client_get_uuid(client);
+#else
+    if (jackbridge_instance()->client_get_uuid_ptr != NULL)
+        return jackbridge_instance()->client_get_uuid_ptr(client);
+#endif
+    return NULL;
+}
+
+char* jackbridge_get_uuid_for_client_name(jack_client_t* client, const char* name)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_uuid_for_client_name(client, name);
+#else
+    if (jackbridge_instance()->get_uuid_for_client_name_ptr != NULL)
+        return jackbridge_instance()->get_uuid_for_client_name_ptr(client, name);
+#endif
+    return NULL;
+}
+
+char* jackbridge_get_client_name_by_uuid(jack_client_t* client, const char* uuid)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_client_name_by_uuid(client, uuid);
+#else
+    if (jackbridge_instance()->get_client_name_by_uuid_ptr != NULL)
+        return jackbridge_instance()->get_client_name_by_uuid_ptr(client, uuid);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_uuid_parse(const char* buf, jack_uuid_t* uuid)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_uuid_parse(buf, uuid) == 0);
+#else
+    if (jackbridge_instance()->uuid_parse_ptr != NULL)
+        return jackbridge_instance()->uuid_parse_ptr(buf, uuid) == 0;
+#endif
+    return false;
+}
+
+void jackbridge_uuid_unparse(jack_uuid_t uuid, char buf[JACK_UUID_STRING_SIZE])
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_uuid_unparse(uuid, buf);
+#else
+    if (jackbridge_instance()->uuid_unparse_ptr != NULL)
+        return jackbridge_instance()->uuid_unparse_ptr(uuid, buf);
+#endif
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_activate(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_activate(client) == 0);
+#else
+    if (jackbridge_instance()->activate_ptr != NULL)
+        return (jackbridge_instance()->activate_ptr(client) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_deactivate(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_deactivate(client) == 0);
+#else
+    if (jackbridge_instance()->deactivate_ptr != NULL)
+        return (jackbridge_instance()->deactivate_ptr(client) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_is_realtime(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_is_realtime(client);
+#else
+    if (jackbridge_instance()->is_realtime_ptr != NULL)
+        return jackbridge_instance()->is_realtime_ptr(client);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_set_thread_init_callback(jack_client_t* client, JackThreadInitCallback thread_init_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_thread_init_callback(client, thread_init_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_thread_init_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_thread_init(thread_init_callback);
+        return (jackbridge_instance()->set_thread_init_callback_ptr(client, WineBridge::thread_init, arg) == 0);
+# else
+        return (jackbridge_instance()->set_thread_init_callback_ptr(client, thread_init_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+void jackbridge_on_shutdown(jack_client_t* client, JackShutdownCallback shutdown_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_on_shutdown(client, shutdown_callback, arg);
+#else
+    if (jackbridge_instance()->on_shutdown_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_shutdown(shutdown_callback);
+        jackbridge_instance()->on_shutdown_ptr(client, WineBridge::shutdown, arg);
+# else
+        jackbridge_instance()->on_shutdown_ptr(client, shutdown_callback, arg);
+# endif
+    }
+#endif
+}
+
+void jackbridge_on_info_shutdown(jack_client_t* client, JackInfoShutdownCallback shutdown_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_on_info_shutdown(client, shutdown_callback, arg);
+#else
+    if (jackbridge_instance()->on_info_shutdown_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_info_shutdown(shutdown_callback);
+        jackbridge_instance()->on_info_shutdown_ptr(client, WineBridge::info_shutdown, arg);
+# else
+        jackbridge_instance()->on_info_shutdown_ptr(client, shutdown_callback, arg);
+# endif
+    }
+#endif
+}
+
+bool jackbridge_set_process_callback(jack_client_t* client, JackProcessCallback process_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_process_callback(client, process_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_process_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_process(process_callback);
+        return (jackbridge_instance()->set_process_callback_ptr(client, WineBridge::process, arg) == 0);
+# else
+        return (jackbridge_instance()->set_process_callback_ptr(client, process_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_freewheel_callback(jack_client_t* client, JackFreewheelCallback freewheel_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_freewheel_callback(client, freewheel_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_freewheel_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_freewheel(freewheel_callback);
+        return (jackbridge_instance()->set_freewheel_callback_ptr(client, WineBridge::freewheel, arg) == 0);
+# else
+        return (jackbridge_instance()->set_freewheel_callback_ptr(client, freewheel_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_buffer_size_callback(jack_client_t* client, JackBufferSizeCallback bufsize_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_buffer_size_callback(client, bufsize_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_buffer_size_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_bufsize(bufsize_callback);
+        return (jackbridge_instance()->set_buffer_size_callback_ptr(client, WineBridge::bufsize, arg) == 0);
+# else
+        return (jackbridge_instance()->set_buffer_size_callback_ptr(client, bufsize_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_sample_rate_callback(jack_client_t* client, JackSampleRateCallback srate_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_sample_rate_callback(client, srate_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_sample_rate_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_srate(srate_callback);
+        return (jackbridge_instance()->set_sample_rate_callback_ptr(client, WineBridge::srate, arg) == 0);
+# else
+        return (jackbridge_instance()->set_sample_rate_callback_ptr(client, srate_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_client_registration_callback(jack_client_t* client, JackClientRegistrationCallback registration_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_client_registration_callback(client, registration_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_client_registration_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_client_reg(registration_callback);
+        return (jackbridge_instance()->set_client_registration_callback_ptr(client, WineBridge::client_reg, arg) == 0);
+# else
+        return (jackbridge_instance()->set_client_registration_callback_ptr(client, registration_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_port_registration_callback(jack_client_t* client, JackPortRegistrationCallback registration_callback, void *arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_port_registration_callback(client, registration_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_port_registration_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_port_reg(registration_callback);
+        return (jackbridge_instance()->set_port_registration_callback_ptr(client, WineBridge::port_reg, arg) == 0);
+# else
+        return (jackbridge_instance()->set_port_registration_callback_ptr(client, registration_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_port_rename_callback(jack_client_t* client, JackPortRenameCallback rename_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_port_rename_callback(client, rename_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_port_rename_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_port_rename(rename_callback);
+        return (jackbridge_instance()->set_port_rename_callback_ptr(client, WineBridge::port_rename, arg) == 0);
+# else
+        return (jackbridge_instance()->set_port_rename_callback_ptr(client, rename_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_port_connect_callback(jack_client_t* client, JackPortConnectCallback connect_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_port_connect_callback(client, connect_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_port_connect_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_port_conn(connect_callback);
+        return (jackbridge_instance()->set_port_connect_callback_ptr(client, WineBridge::port_conn, arg) == 0);
+# else
+        return (jackbridge_instance()->set_port_connect_callback_ptr(client, connect_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_graph_order_callback(jack_client_t* client, JackGraphOrderCallback graph_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_graph_order_callback(client, graph_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_graph_order_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_graph_order(graph_callback);
+        return (jackbridge_instance()->set_graph_order_callback_ptr(client, WineBridge::graph_order, arg) == 0);
+# else
+        return (jackbridge_instance()->set_graph_order_callback_ptr(client, graph_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_xrun_callback(jack_client_t* client, JackXRunCallback xrun_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_xrun_callback(client, xrun_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_xrun_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_xrun(xrun_callback);
+        return (jackbridge_instance()->set_xrun_callback_ptr(client, WineBridge::xrun, arg) == 0);
+# else
+        return (jackbridge_instance()->set_xrun_callback_ptr(client, xrun_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_latency_callback(jack_client_t* client, JackLatencyCallback latency_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_latency_callback(client, latency_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_latency_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_latency(latency_callback);
+        return (jackbridge_instance()->set_latency_callback_ptr(client, WineBridge::latency, arg) == 0);
+# else
+        return (jackbridge_instance()->set_latency_callback_ptr(client, latency_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_set_freewheel(jack_client_t* client, bool onoff)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_set_freewheel(client, onoff);
+#else
+    if (jackbridge_instance()->set_freewheel_ptr != NULL)
+        return jackbridge_instance()->set_freewheel_ptr(client, onoff);
+#endif
+    return false;
+}
+
+bool jackbridge_set_buffer_size(jack_client_t* client, jack_nframes_t nframes)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_set_buffer_size(client, nframes);
+#else
+    if (jackbridge_instance()->set_buffer_size_ptr != NULL)
+        return jackbridge_instance()->set_buffer_size_ptr(client, nframes);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+jack_nframes_t jackbridge_get_sample_rate(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_sample_rate(client);
+#else
+    if (jackbridge_instance()->get_sample_rate_ptr != NULL)
+        return jackbridge_instance()->get_sample_rate_ptr(client);
+#endif
+    return 0;
+}
+
+jack_nframes_t jackbridge_get_buffer_size(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_buffer_size(client);
+#else
+    if (jackbridge_instance()->get_buffer_size_ptr != NULL)
+        return jackbridge_instance()->get_buffer_size_ptr(client);
+#endif
+    return 0;
+}
+
+float jackbridge_cpu_load(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_cpu_load(client);
+#else
+    if (jackbridge_instance()->cpu_load_ptr != NULL)
+        return jackbridge_instance()->cpu_load_ptr(client);
+#endif
+    return 0.0f;
+}
+
+// -----------------------------------------------------------------------------
+
+jack_port_t* jackbridge_port_register(jack_client_t* client, const char* port_name, const char* type, uint64_t flags, uint64_t buffer_size)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_register(client, port_name, type, flags, buffer_size);
+#else
+    if (jackbridge_instance()->port_register_ptr != NULL)
+        return jackbridge_instance()->port_register_ptr(client, port_name, type, (ulong)flags, (ulong)buffer_size);
+#endif
+    return NULL;
+}
+
+bool jackbridge_port_unregister(jack_client_t* client, jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_unregister(client, port) == 0);
+#else
+    if (jackbridge_instance()->port_unregister_ptr != NULL)
+        return (jackbridge_instance()->port_unregister_ptr(client, port) == 0);
+#endif
+    return false;
+}
+
+void* jackbridge_port_get_buffer(jack_port_t* port, jack_nframes_t nframes)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_get_buffer(port, nframes);
+#else
+    if (jackbridge_instance()->port_get_buffer_ptr != NULL)
+        return jackbridge_instance()->port_get_buffer_ptr(port, nframes);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+const char* jackbridge_port_name(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_name(port);
+#else
+    if (jackbridge_instance()->port_name_ptr != NULL)
+        return jackbridge_instance()->port_name_ptr(port);
+#endif
+    return NULL;
+}
+
+jack_uuid_t jackbridge_port_uuid(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_uuid(port);
+#else
+    if (jackbridge_instance()->port_uuid_ptr != NULL)
+        return jackbridge_instance()->port_uuid_ptr(port);
+#endif
+    return 0;
+}
+
+const char* jackbridge_port_short_name(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_short_name(port);
+#else
+    if (jackbridge_instance()->port_short_name_ptr != NULL)
+        return jackbridge_instance()->port_short_name_ptr(port);
+#endif
+    return NULL;
+}
+
+int jackbridge_port_flags(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_flags(port);
+#else
+    if (jackbridge_instance()->port_flags_ptr != NULL)
+        return jackbridge_instance()->port_flags_ptr(port);
+#endif
+    return 0x0;
+}
+
+const char* jackbridge_port_type(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_type(port);
+#else
+    if (jackbridge_instance()->port_type_ptr != NULL)
+        return jackbridge_instance()->port_type_ptr(port);
+#endif
+    return NULL;
+}
+
+bool jackbridge_port_is_mine(const jack_client_t* client, const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_is_mine(client, port);
+#else
+    if (jackbridge_instance()->port_is_mine_ptr != NULL)
+        return jackbridge_instance()->port_is_mine_ptr(client, port);
+#endif
+    return false;
+}
+
+int jackbridge_port_connected(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_connected(port);
+#else
+    if (jackbridge_instance()->port_connected_ptr != NULL)
+        return jackbridge_instance()->port_connected_ptr(port);
+#endif
+    return 0;
+}
+
+bool jackbridge_port_connected_to(const jack_port_t* port, const char* port_name)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_connected_to(port, port_name);
+#else
+    if (jackbridge_instance()->port_connected_to_ptr != NULL)
+        return jackbridge_instance()->port_connected_to_ptr(port, port_name);
+#endif
+    return false;
+}
+
+const char** jackbridge_port_get_connections(const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_get_connections(port);
+#else
+    if (jackbridge_instance()->port_get_connections_ptr != NULL)
+        return jackbridge_instance()->port_get_connections_ptr(port);
+#endif
+    return NULL;
+}
+
+const char** jackbridge_port_get_all_connections(const jack_client_t* client, const jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_get_all_connections(client, port);
+#else
+    if (jackbridge_instance()->port_get_all_connections_ptr != NULL)
+        return jackbridge_instance()->port_get_all_connections_ptr(client, port);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_port_rename(jack_client_t* client, jack_port_t* port, const char* port_name)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_rename(client, port, port_name) == 0);
+#else
+    // Try new API first
+    if (jackbridge_instance()->port_rename_ptr != NULL)
+        return (jackbridge_instance()->port_rename_ptr(client, port, port_name) == 0);
+    // Try old API if using JACK2
+    if (jackbridge_instance()->get_version_string_ptr != NULL && jackbridge_instance()->port_set_name_ptr != NULL)
+        return (jackbridge_instance()->port_set_name_ptr(port, port_name) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_set_alias(jack_port_t* port, const char* alias)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_set_alias(port, alias) == 0);
+#else
+    if (jackbridge_instance()->port_set_alias_ptr != NULL)
+        return (jackbridge_instance()->port_set_alias_ptr(port, alias) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_unset_alias(jack_port_t* port, const char* alias)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_unset_alias(port, alias) == 0);
+#else
+    if (jackbridge_instance()->port_unset_alias_ptr != NULL)
+        return (jackbridge_instance()->port_unset_alias_ptr(port, alias) == 0);
+#endif
+    return false;
+}
+
+int jackbridge_port_get_aliases(const jack_port_t* port, char* const aliases[2])
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_get_aliases(port, aliases) == 0);
+#else
+    if (jackbridge_instance()->port_get_aliases_ptr != NULL)
+        return jackbridge_instance()->port_get_aliases_ptr(port, aliases);
+#endif
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_port_request_monitor(jack_port_t* port, bool onoff)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_request_monitor(port, onoff) == 0);
+#else
+    if (jackbridge_instance()->port_request_monitor_ptr != NULL)
+        return (jackbridge_instance()->port_request_monitor_ptr(port, onoff) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_request_monitor_by_name(jack_client_t* client, const char* port_name, bool onoff)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_request_monitor_by_name(client, port_name, onoff) == 0);
+#else
+    if (jackbridge_instance()->port_request_monitor_by_name_ptr != NULL)
+        return (jackbridge_instance()->port_request_monitor_by_name_ptr(client, port_name, onoff) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_ensure_monitor(jack_port_t* port, bool onoff)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_ensure_monitor(port, onoff) == 0);
+#else
+    if (jackbridge_instance()->port_ensure_monitor_ptr != NULL)
+        return (jackbridge_instance()->port_ensure_monitor_ptr(port, onoff) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_monitoring_input(jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_monitoring_input(port);
+#else
+    if (jackbridge_instance()->port_monitoring_input_ptr != NULL)
+        return jackbridge_instance()->port_monitoring_input_ptr(port);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_connect(jack_client_t* client, const char* source_port, const char* destination_port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_connect(client, source_port, destination_port) == 0);
+#else
+    if (jackbridge_instance()->connect_ptr != NULL)
+    {
+        const int ret = jackbridge_instance()->connect_ptr(client, source_port, destination_port);
+        return ret == 0 || ret == EEXIST;
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_disconnect(jack_client_t* client, const char* source_port, const char* destination_port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_disconnect(client, source_port, destination_port) == 0);
+#else
+    if (jackbridge_instance()->disconnect_ptr != NULL)
+        return (jackbridge_instance()->disconnect_ptr(client, source_port, destination_port) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_port_disconnect(jack_client_t* client, jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_port_disconnect(client, port) == 0);
+#else
+    if (jackbridge_instance()->port_disconnect_ptr != NULL)
+        return (jackbridge_instance()->port_disconnect_ptr(client, port) == 0);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+int jackbridge_port_name_size()
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_name_size();
+#else
+    if (jackbridge_instance()->port_name_size_ptr != NULL)
+        return jackbridge_instance()->port_name_size_ptr();
+#endif
+    return 256;
+}
+
+int jackbridge_port_type_size()
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_type_size();
+#else
+    if (jackbridge_instance()->port_type_size_ptr != NULL)
+        return jackbridge_instance()->port_type_size_ptr();
+#endif
+    return 32;
+}
+
+uint32_t jackbridge_port_type_get_buffer_size(jack_client_t* client, const char* port_type)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (uint32_t)jack_port_type_get_buffer_size(client, port_type);
+#else
+    if (jackbridge_instance()->port_type_get_buffer_size_ptr != NULL)
+        return (uint32_t)jackbridge_instance()->port_type_get_buffer_size_ptr(client, port_type);
+#endif
+    return 0;
+}
+
+// -----------------------------------------------------------------------------
+
+void jackbridge_port_get_latency_range(jack_port_t* port, uint32_t mode, jack_latency_range_t* range)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_get_latency_range(port, (jack_latency_callback_mode_t)mode, range);
+#else
+    if (jackbridge_instance()->port_get_latency_range_ptr != NULL)
+        return jackbridge_instance()->port_get_latency_range_ptr(port, (jack_latency_callback_mode_t)mode, range);
+#endif
+    range->min = 0;
+    range->max = 0;
+}
+
+void jackbridge_port_set_latency_range(jack_port_t* port, uint32_t mode, jack_latency_range_t* range)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_port_set_latency_range(port, (jack_latency_callback_mode_t)mode, range);
+#else
+    if (jackbridge_instance()->port_set_latency_range_ptr != NULL)
+        jackbridge_instance()->port_set_latency_range_ptr(port, (jack_latency_callback_mode_t)mode, range);
+#endif
+}
+
+bool jackbridge_recompute_total_latencies(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_recompute_total_latencies(client) == 0);
+#else
+    if (jackbridge_instance()->recompute_total_latencies_ptr != NULL)
+        return (jackbridge_instance()->recompute_total_latencies_ptr(client) == 0);
+#endif
+    return false;
+}
+
+// -----------------------------------------------------------------------------
+
+const char** jackbridge_get_ports(jack_client_t* client, const char* port_name_pattern, const char* type_name_pattern, uint64_t flags)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_ports(client, port_name_pattern, type_name_pattern, flags);
+#else
+    if (jackbridge_instance()->get_ports_ptr != NULL)
+        return jackbridge_instance()->get_ports_ptr(client, port_name_pattern, type_name_pattern, (ulong)flags);
+#endif
+    return NULL;
+}
+
+jack_port_t* jackbridge_port_by_name(jack_client_t* client, const char* port_name)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_by_name(client, port_name);
+#else
+    if (jackbridge_instance()->port_by_name_ptr != NULL)
+        return jackbridge_instance()->port_by_name_ptr(client, port_name);
+#endif
+    return NULL;
+}
+
+jack_port_t* jackbridge_port_by_id(jack_client_t* client, jack_port_id_t port_id)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_by_id(client, port_id);
+#else
+    if (jackbridge_instance()->port_by_id_ptr != NULL)
+        return jackbridge_instance()->port_by_id_ptr(client, port_id);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+void jackbridge_free(void* ptr)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_free(ptr);
+#else
+    if (jackbridge_instance()->free_ptr != NULL)
+        return jackbridge_instance()->free_ptr(ptr);
+
+   #ifndef _WIN32
+    free(ptr);
+   #endif
+#endif
+}
+
+// -----------------------------------------------------------------------------
+
+uint32_t jackbridge_midi_get_event_count(void* port_buffer)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_midi_get_event_count(port_buffer);
+#else
+    if (jackbridge_instance()->midi_get_event_count_ptr != NULL)
+        return jackbridge_instance()->midi_get_event_count_ptr(port_buffer);
+#endif
+    return 0;
+}
+
+bool jackbridge_midi_event_get(jack_midi_event_t* event, void* port_buffer, uint32_t event_index)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_midi_event_get(event, port_buffer, event_index) == 0);
+#else
+    if (jackbridge_instance()->midi_event_get_ptr != NULL)
+        return (jackbridge_instance()->midi_event_get_ptr(event, port_buffer, event_index) == 0);
+#endif
+    return false;
+}
+
+void jackbridge_midi_clear_buffer(void* port_buffer)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_midi_clear_buffer(port_buffer);
+#else
+    if (jackbridge_instance()->midi_clear_buffer_ptr != NULL)
+        jackbridge_instance()->midi_clear_buffer_ptr(port_buffer);
+#endif
+}
+
+bool jackbridge_midi_event_write(void* port_buffer, jack_nframes_t time, const jack_midi_data_t* data, uint32_t data_size)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_midi_event_write(port_buffer, time, data, data_size) == 0);
+#else
+    if (jackbridge_instance()->midi_event_write_ptr != NULL)
+        return (jackbridge_instance()->midi_event_write_ptr(port_buffer, time, data, data_size) == 0);
+#endif
+    return false;
+}
+
+jack_midi_data_t* jackbridge_midi_event_reserve(void* port_buffer, jack_nframes_t time, uint32_t data_size)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_midi_event_reserve(port_buffer, time, data_size);
+#else
+    if (jackbridge_instance()->midi_event_reserve_ptr != NULL)
+        return jackbridge_instance()->midi_event_reserve_ptr(port_buffer, time, data_size);
+#endif
+    return NULL;
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_release_timebase(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_release_timebase(client) == 0);
+#else
+    if (jackbridge_instance()->release_timebase_ptr != NULL)
+        return (jackbridge_instance()->release_timebase_ptr(client) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_set_sync_callback(jack_client_t* client, JackSyncCallback sync_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_sync_callback(client, sync_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_sync_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_sync(sync_callback);
+        return (jackbridge_instance()->set_sync_callback_ptr(client, WineBridge::sync, arg) == 0);
+# else
+        return (jackbridge_instance()->set_sync_callback_ptr(client, sync_callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_sync_timeout(jack_client_t* client, jack_time_t timeout)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_sync_timeout(client, timeout) == 0);
+#else
+    if (jackbridge_instance()->set_sync_timeout_ptr != NULL)
+        return (jackbridge_instance()->set_sync_timeout_ptr(client, timeout) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_set_timebase_callback(jack_client_t* client, bool conditional, JackTimebaseCallback timebase_callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_timebase_callback(client, conditional, timebase_callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_timebase_callback_ptr != NULL)
+        return (jackbridge_instance()->set_timebase_callback_ptr(client, conditional, timebase_callback, arg) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_transport_locate(jack_client_t* client, jack_nframes_t frame)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_transport_locate(client, frame) == 0);
+#else
+    if (jackbridge_instance()->transport_locate_ptr != NULL)
+        return (jackbridge_instance()->transport_locate_ptr(client, frame) == 0);
+#endif
+    return false;
+}
+
+uint32_t jackbridge_transport_query(const jack_client_t* client, jack_position_t* pos)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_transport_query(client, pos);
+#else
+    if (jackbridge_instance()->transport_query_ptr != NULL)
+        return jackbridge_instance()->transport_query_ptr(client, pos);
+#endif
+    if (pos != NULL)
+    {
+        // invalidate
+        memset(pos, 0, sizeof(*pos));
+        pos->unique_1 = 0;
+        pos->unique_2 = 1;
+    }
+    return JackTransportStopped;
+}
+
+jack_nframes_t jackbridge_get_current_transport_frame(const jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_get_current_transport_frame(client);
+#else
+    if (jackbridge_instance()->get_current_transport_frame_ptr != NULL)
+        return jackbridge_instance()->get_current_transport_frame_ptr(client);
+#endif
+    return 0;
+}
+
+bool jackbridge_transport_reposition(jack_client_t* client, const jack_position_t* pos)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_transport_reposition(client, pos) == 0);
+#else
+    if (jackbridge_instance()->transport_reposition_ptr != NULL)
+        return (jackbridge_instance()->transport_reposition_ptr(client, pos) == 0);
+#endif
+    return false;
+}
+
+void jackbridge_transport_start(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_transport_start(client);
+#else
+    if (jackbridge_instance()->transport_start_ptr != NULL)
+        jackbridge_instance()->transport_start_ptr(client);
+#endif
+}
+
+void jackbridge_transport_stop(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_transport_stop(client);
+#else
+    if (jackbridge_instance()->transport_stop_ptr != NULL)
+        jackbridge_instance()->transport_stop_ptr(client);
+#endif
+}
+
+// -----------------------------------------------------------------------------
+
+bool jackbridge_set_property(jack_client_t* client, jack_uuid_t subject, const char* key, const char* value, const char* type)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_property(client, subject, key, value, type) == 0);
+#else
+    if (jackbridge_instance()->set_property_ptr != NULL)
+        return (jackbridge_instance()->set_property_ptr(client, subject, key, value, type) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_get_property(jack_uuid_t subject, const char* key, char** value, char** type)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_get_property(subject, key, value, type) == 0);
+#else
+    if (jackbridge_instance()->get_property_ptr != NULL)
+        return (jackbridge_instance()->get_property_ptr(subject, key, value, type) == 0);
+#endif
+    return false;
+}
+
+void jackbridge_free_description(jack_description_t* desc, bool free_description_itself)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_free_description(desc, free_description_itself);
+#else
+    if (jackbridge_instance()->free_description_ptr != NULL)
+        jackbridge_instance()->free_description_ptr(desc, free_description_itself);
+#endif
+}
+
+bool jackbridge_get_properties(jack_uuid_t subject, jack_description_t* desc)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_get_properties(subject, desc) == 0);
+#else
+    if (jackbridge_instance()->get_properties_ptr != NULL)
+        return (jackbridge_instance()->get_properties_ptr(subject, desc) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_get_all_properties(jack_description_t** descs)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_get_all_properties(descs) == 0);
+#else
+    if (jackbridge_instance()->get_all_properties_ptr != NULL)
+        return (jackbridge_instance()->get_all_properties_ptr(descs) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_remove_property(jack_client_t* client, jack_uuid_t subject, const char* key)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_remove_property(client, subject, key) == 0);
+#else
+    if (jackbridge_instance()->remove_property_ptr != NULL)
+        return (jackbridge_instance()->remove_property_ptr(client, subject, key) == 0);
+#endif
+    return false;
+}
+
+int jackbridge_remove_properties(jack_client_t* client, jack_uuid_t subject)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_remove_properties(client, subject);
+#else
+    if (jackbridge_instance()->remove_properties_ptr != NULL)
+        return jackbridge_instance()->remove_properties_ptr(client, subject);
+#endif
+    return 0;
+}
+
+bool jackbridge_remove_all_properties(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_remove_all_properties(client) == 0);
+#else
+    if (jackbridge_instance()->remove_all_properties_ptr != NULL)
+        return (jackbridge_instance()->remove_all_properties_ptr(client) == 0);
+#endif
+    return false;
+}
+
+bool jackbridge_set_property_change_callback(jack_client_t* client, JackPropertyChangeCallback callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_property_change_callback(client, callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_property_change_callback_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_prop_change(callback);
+        return (jackbridge_instance()->set_property_change_callback_ptr(client, WineBridge::prop_change, arg) == 0);
+# else
+        return (jackbridge_instance()->set_property_change_callback_ptr(client, callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+bool jackbridge_set_process_thread(jack_client_t* client, JackThreadCallback callback, void* arg)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return (jack_set_process_thread(client, callback, arg) == 0);
+#else
+    if (jackbridge_instance()->set_process_thread_ptr != NULL)
+    {
+# ifdef __WINE__
+        WineBridge::getInstance().set_process_thread(callback);
+        return (jackbridge_instance()->set_process_thread_ptr(client, WineBridge::process_thread, arg) == 0);
+# else
+        return (jackbridge_instance()->set_process_thread_ptr(client, callback, arg) == 0);
+# endif
+    }
+#endif
+    return false;
+}
+
+jack_nframes_t jackbridge_cycle_wait(jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_cycle_wait(client);
+#else
+    if (jackbridge_instance()->cycle_wait_ptr != NULL)
+        return jackbridge_instance()->cycle_wait_ptr(client);
+#endif
+    return 0;
+}
+
+void jackbridge_cycle_signal(jack_client_t* client, int status)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    jack_cycle_signal(client, status);
+#else
+    if (jackbridge_instance()->cycle_signal_ptr != NULL)
+        jackbridge_instance()->cycle_signal_ptr(client, status);
+#endif
+}
+
+jack_nframes_t jackbridge_port_get_latency(jack_port_t* port)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jack_port_get_latency(port);
+#else
+    if (jackbridge_instance()->port_get_latency_ptr != NULL)
+        jackbridge_instance()->port_get_latency_ptr(port);
+    return 0;
+#endif
+}
+
+jack_nframes_t jackbridge_frame_time(const jack_client_t* client)
+{
+#if defined(JACKBRIDGE_DUMMY)
+#elif defined(JACKBRIDGE_DIRECT)
+    return jackbridge_frame_time(client);
+#else
+    if (jackbridge_instance()->frame_time_ptr != NULL)
+        jackbridge_instance()->frame_time_ptr(client);
+    return 0;
+#endif
+}
diff --git a/src/hostapi/jack/JackBridge.h b/src/hostapi/jack/JackBridge.h
new file mode 100644
index 0000000..eff8cb0
--- /dev/null
+++ b/src/hostapi/jack/JackBridge.h
@@ -0,0 +1,406 @@
+/*
+ * JackBridge for DPF
+ * Copyright (C) 2013-2021 Filipe Coelho <falktx@falktx.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any purpose with
+ * or without fee is hereby granted, provided that the above copyright notice and this
+ * permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef JACKBRIDGE_HPP_INCLUDED
+#define JACKBRIDGE_HPP_INCLUDED
+
+#if defined(_WIN32) && defined(__cdecl)
+# define JACKBRIDGE_API __cdecl
+#else
+# define JACKBRIDGE_API
+#endif
+
+#ifdef JACKBRIDGE_DIRECT
+# include <jack/jack.h>
+# include <jack/midiport.h>
+# include <jack/transport.h>
+# include <jack/session.h>
+# include <jack/metadata.h>
+# include <jack/uuid.h>
+#else
+
+#include <stdbool.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#ifndef POST_PACKED_STRUCTURE
+# if defined(__GNUC__)
+  /* POST_PACKED_STRUCTURE needs to be a macro which
+      expands into a compiler directive. The directive must
+      tell the compiler to arrange the preceding structure
+      declaration so that it is packed on byte-boundaries rather
+      than use the natural alignment of the processor and/or
+      compiler.
+  */
+  #define PRE_PACKED_STRUCTURE
+  #define POST_PACKED_STRUCTURE __attribute__((__packed__))
+# elif defined(_MSC_VER)
+  #define PRE_PACKED_STRUCTURE1 __pragma(pack(push,1))
+  #define PRE_PACKED_STRUCTURE    PRE_PACKED_STRUCTURE1
+  /* PRE_PACKED_STRUCTURE needs to be a macro which
+      expands into a compiler directive. The directive must
+      tell the compiler to arrange the following structure
+      declaration so that it is packed on byte-boundaries rather
+      than use the natural alignment of the processor and/or
+      compiler.
+  */
+  #define POST_PACKED_STRUCTURE ;__pragma(pack(pop))
+  /* and POST_PACKED_STRUCTURE needs to be a macro which
+      restores the packing to its previous setting */
+# else
+  #define PRE_PACKED_STRUCTURE
+  #define POST_PACKED_STRUCTURE
+# endif
+#endif
+
+#if (defined(__arm__) || defined(__aarch64__) || defined(__mips__) || defined(__ppc__) || defined(__powerpc__)) && !defined(__APPLE__)
+# undef POST_PACKED_STRUCTURE
+# define POST_PACKED_STRUCTURE
+#endif
+
+#define JACK_DEFAULT_AUDIO_TYPE "32 bit float mono audio"
+#define JACK_DEFAULT_MIDI_TYPE  "8 bit raw midi"
+
+#define JACK_MAX_FRAMES (4294967295U)
+
+#define JackOpenOptions (JackSessionID|JackServerName|JackNoStartServer|JackUseExactName)
+#define JackLoadOptions (JackLoadInit|JackLoadName|JackUseExactName)
+
+#define JACK_POSITION_MASK (JackPositionBBT|JackPositionTimecode|JackBBTFrameOffset|JackAudioVideoRatio|JackVideoFrameOffset)
+#define EXTENDED_TIME_INFO
+
+#define JACK_UUID_SIZE 36
+#define JACK_UUID_STRING_SIZE (JACK_UUID_SIZE+1) /* includes trailing null */
+#define JACK_UUID_EMPTY_INITIALIZER 0
+
+#define JACK_TICK_DOUBLE
+
+enum JackOptions {
+    JackNullOption    = 0x00,
+    JackNoStartServer = 0x01,
+    JackUseExactName  = 0x02,
+    JackServerName    = 0x04,
+    JackLoadName      = 0x08,
+    JackLoadInit      = 0x10,
+    JackSessionID     = 0x20
+};
+
+enum JackStatus {
+    JackFailure       = 0x0001,
+    JackInvalidOption = 0x0002,
+    JackNameNotUnique = 0x0004,
+    JackServerStarted = 0x0008,
+    JackServerFailed  = 0x0010,
+    JackServerError   = 0x0020,
+    JackNoSuchClient  = 0x0040,
+    JackLoadFailure   = 0x0080,
+    JackInitFailure   = 0x0100,
+    JackShmFailure    = 0x0200,
+    JackVersionError  = 0x0400,
+    JackBackendError  = 0x0800,
+    JackClientZombie  = 0x1000,
+    JackBridgeNativeFailed = 0x10000
+};
+
+enum JackLatencyCallbackMode {
+    JackCaptureLatency,
+    JackPlaybackLatency
+};
+
+enum JackPortFlags {
+    JackPortIsInput    = 0x01,
+    JackPortIsOutput   = 0x02,
+    JackPortIsPhysical = 0x04,
+    JackPortCanMonitor = 0x08,
+    JackPortIsTerminal = 0x10,
+    JackPortIsControlVoltage = 0x100
+};
+
+enum JackTransportState {
+    JackTransportStopped  = 0,
+    JackTransportRolling  = 1,
+    JackTransportLooping  = 2,
+    JackTransportStarting = 3
+};
+
+enum JackPositionBits {
+    JackPositionBBT      = 0x010,
+    JackPositionTimecode = 0x020,
+    JackBBTFrameOffset   = 0x040,
+    JackAudioVideoRatio  = 0x080,
+    JackVideoFrameOffset = 0x100,
+    JackTickDouble       = 0x200
+};
+
+enum JackSessionEventType {
+    JackSessionSave         = 1,
+    JackSessionSaveAndQuit  = 2,
+    JackSessionSaveTemplate = 3
+};
+
+enum JackSessionFlags {
+    JackSessionSaveError    = 0x1,
+    JackSessionNeedTerminal = 0x2
+};
+
+enum JackPropertyChange {
+    PropertyCreated,
+    PropertyChanged,
+    PropertyDeleted
+};
+
+typedef uint32_t jack_nframes_t;
+typedef uint32_t jack_port_id_t;
+typedef uint64_t jack_time_t;
+typedef uint64_t jack_uuid_t;
+typedef uint64_t jack_unique_t;
+typedef unsigned char jack_midi_data_t;
+typedef float jack_default_audio_sample_t;
+
+typedef enum JackOptions jack_options_t;
+typedef enum JackStatus jack_status_t;
+typedef enum JackLatencyCallbackMode jack_latency_callback_mode_t;
+typedef enum JackTransportState jack_transport_state_t;
+typedef enum JackPositionBits jack_position_bits_t;
+typedef enum JackSessionEventType jack_session_event_type_t;
+typedef enum JackSessionFlags jack_session_flags_t;
+typedef enum JackPropertyChange jack_property_change_t;
+
+struct _jack_midi_event {
+    jack_nframes_t    time;
+    size_t            size;
+    jack_midi_data_t* buffer;
+};
+
+// NOTE: packed in JACK2 but not in JACK1
+PRE_PACKED_STRUCTURE
+struct _jack_latency_range {
+    jack_nframes_t min;
+    jack_nframes_t max;
+} POST_PACKED_STRUCTURE;
+
+PRE_PACKED_STRUCTURE
+struct _jack_position {
+    jack_unique_t  unique_1;
+    jack_time_t    usecs;
+    jack_nframes_t frame_rate;
+    jack_nframes_t frame;
+    jack_position_bits_t valid;
+    int32_t bar;
+    int32_t beat;
+    int32_t tick;
+    double  bar_start_tick;
+    float   beats_per_bar;
+    float   beat_type;
+    double  ticks_per_beat;
+    double  beats_per_minute;
+    double  frame_time;
+    double  next_time;
+    jack_nframes_t bbt_offset;
+    float          audio_frames_per_video_frame;
+    jack_nframes_t video_offset;
+    double         tick_double;
+    int32_t        padding[5];
+    jack_unique_t  unique_2;
+} POST_PACKED_STRUCTURE;
+
+struct _jack_session_event {
+    jack_session_event_type_t type;
+    const char* session_dir;
+    const char* client_uuid;
+    char*       command_line;
+    jack_session_flags_t flags;
+    uint32_t future;
+};
+
+struct _jack_session_command_t {
+    const char* uuid;
+    const char* client_name;
+    const char* command;
+    jack_session_flags_t flags;
+};
+
+typedef struct {
+    const char* key;
+    const char* data;
+    const char* type;
+} jack_property_t;
+
+typedef struct {
+    jack_uuid_t      subject;
+    uint32_t         property_cnt;
+    jack_property_t* properties;
+    uint32_t         property_size;
+} jack_description_t;
+
+typedef struct _jack_port jack_port_t;
+typedef struct _jack_client jack_client_t;
+typedef struct _jack_midi_event jack_midi_event_t;
+typedef struct _jack_latency_range jack_latency_range_t;
+typedef struct _jack_position jack_position_t;
+typedef struct _jack_session_event jack_session_event_t;
+typedef struct _jack_session_command_t jack_session_command_t;
+
+typedef void (JACKBRIDGE_API *JackLatencyCallback)(jack_latency_callback_mode_t mode, void* arg);
+typedef int  (JACKBRIDGE_API *JackProcessCallback)(jack_nframes_t nframes, void* arg);
+typedef void (JACKBRIDGE_API *JackThreadInitCallback)(void* arg);
+typedef int  (JACKBRIDGE_API *JackGraphOrderCallback)(void* arg);
+typedef int  (JACKBRIDGE_API *JackXRunCallback)(void* arg);
+typedef int  (JACKBRIDGE_API *JackBufferSizeCallback)(jack_nframes_t nframes, void* arg);
+typedef int  (JACKBRIDGE_API *JackSampleRateCallback)(jack_nframes_t nframes, void* arg);
+typedef void (JACKBRIDGE_API *JackPortRegistrationCallback)(jack_port_id_t port, int register_, void* arg);
+typedef void (JACKBRIDGE_API *JackClientRegistrationCallback)(const char* name, int register_, void* arg);
+typedef void (JACKBRIDGE_API *JackPortConnectCallback)(jack_port_id_t a, jack_port_id_t b, int connect, void* arg);
+typedef void (JACKBRIDGE_API *JackPortRenameCallback)(jack_port_id_t port, const char* old_name, const char* new_name, void* arg);
+typedef void (JACKBRIDGE_API *JackFreewheelCallback)(int starting, void* arg);
+typedef void (JACKBRIDGE_API *JackShutdownCallback)(void* arg);
+typedef void (JACKBRIDGE_API *JackInfoShutdownCallback)(jack_status_t code, const char* reason, void* arg);
+typedef int  (JACKBRIDGE_API *JackSyncCallback)(jack_transport_state_t state, jack_position_t* pos, void* arg);
+typedef void (JACKBRIDGE_API *JackTimebaseCallback)(jack_transport_state_t state, jack_nframes_t nframes, jack_position_t* pos, int new_pos, void* arg);
+typedef void (JACKBRIDGE_API *JackSessionCallback)(jack_session_event_t* event, void* arg);
+typedef void (JACKBRIDGE_API *JackPropertyChangeCallback)(jack_uuid_t subject, const char* key, jack_property_change_t change, void* arg);
+typedef void *(JACKBRIDGE_API *JackThreadCallback)(void* arg);
+
+#endif // ! JACKBRIDGE_DIRECT
+
+JACKBRIDGE_API bool jackbridge_is_ok();
+
+JACKBRIDGE_API void        jackbridge_get_version(int* major_ptr, int* minor_ptr, int* micro_ptr, int* proto_ptr);
+JACKBRIDGE_API const char* jackbridge_get_version_string();
+
+JACKBRIDGE_API jack_client_t* jackbridge_client_open(const char* client_name, uint32_t options, jack_status_t* status);
+JACKBRIDGE_API bool           jackbridge_client_close(jack_client_t* client);
+
+JACKBRIDGE_API int         jackbridge_client_name_size();
+JACKBRIDGE_API const char* jackbridge_get_client_name(jack_client_t* client);
+
+JACKBRIDGE_API char* jackbridge_client_get_uuid(jack_client_t* client);
+JACKBRIDGE_API char* jackbridge_get_uuid_for_client_name(jack_client_t* client, const char* name);
+JACKBRIDGE_API char* jackbridge_get_client_name_by_uuid(jack_client_t* client, const char* uuid);
+
+JACKBRIDGE_API bool jackbridge_uuid_parse(const char* buf, jack_uuid_t* uuid);
+JACKBRIDGE_API void jackbridge_uuid_unparse(jack_uuid_t uuid, char buf[JACK_UUID_STRING_SIZE]);
+
+JACKBRIDGE_API bool jackbridge_activate(jack_client_t* client);
+JACKBRIDGE_API bool jackbridge_deactivate(jack_client_t* client);
+JACKBRIDGE_API bool jackbridge_is_realtime(jack_client_t* client);
+
+JACKBRIDGE_API bool jackbridge_set_thread_init_callback(jack_client_t* client, JackThreadInitCallback thread_init_callback, void* arg);
+JACKBRIDGE_API void jackbridge_on_shutdown(jack_client_t* client, JackShutdownCallback shutdown_callback, void* arg);
+JACKBRIDGE_API void jackbridge_on_info_shutdown(jack_client_t* client, JackInfoShutdownCallback shutdown_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_process_callback(jack_client_t* client, JackProcessCallback process_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_freewheel_callback(jack_client_t* client, JackFreewheelCallback freewheel_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_buffer_size_callback(jack_client_t* client, JackBufferSizeCallback bufsize_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_sample_rate_callback(jack_client_t* client, JackSampleRateCallback srate_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_client_registration_callback(jack_client_t* client, JackClientRegistrationCallback registration_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_port_registration_callback(jack_client_t* client, JackPortRegistrationCallback registration_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_port_rename_callback(jack_client_t* client, JackPortRenameCallback rename_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_port_connect_callback(jack_client_t* client, JackPortConnectCallback connect_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_graph_order_callback(jack_client_t* client, JackGraphOrderCallback graph_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_xrun_callback(jack_client_t* client, JackXRunCallback xrun_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_latency_callback(jack_client_t* client, JackLatencyCallback latency_callback, void* arg);
+
+JACKBRIDGE_API bool jackbridge_set_freewheel(jack_client_t* client, bool onoff);
+JACKBRIDGE_API bool jackbridge_set_buffer_size(jack_client_t* client, jack_nframes_t nframes);
+
+JACKBRIDGE_API jack_nframes_t jackbridge_get_sample_rate(jack_client_t* client);
+JACKBRIDGE_API jack_nframes_t jackbridge_get_buffer_size(jack_client_t* client);
+JACKBRIDGE_API float          jackbridge_cpu_load(jack_client_t* client);
+
+JACKBRIDGE_API jack_port_t* jackbridge_port_register(jack_client_t* client, const char* port_name, const char* port_type, uint64_t flags, uint64_t buffer_size);
+JACKBRIDGE_API bool         jackbridge_port_unregister(jack_client_t* client, jack_port_t* port);
+JACKBRIDGE_API void*        jackbridge_port_get_buffer(jack_port_t* port, jack_nframes_t nframes);
+
+JACKBRIDGE_API const char*  jackbridge_port_name(const jack_port_t* port);
+JACKBRIDGE_API jack_uuid_t  jackbridge_port_uuid(const jack_port_t* port);
+JACKBRIDGE_API const char*  jackbridge_port_short_name(const jack_port_t* port);
+JACKBRIDGE_API int          jackbridge_port_flags(const jack_port_t* port);
+JACKBRIDGE_API const char*  jackbridge_port_type(const jack_port_t* port);
+JACKBRIDGE_API bool         jackbridge_port_is_mine(const jack_client_t* client, const jack_port_t* port);
+JACKBRIDGE_API int          jackbridge_port_connected(const jack_port_t* port);
+JACKBRIDGE_API bool         jackbridge_port_connected_to(const jack_port_t* port, const char* port_name);
+JACKBRIDGE_API const char** jackbridge_port_get_connections(const jack_port_t* port);
+JACKBRIDGE_API const char** jackbridge_port_get_all_connections(const jack_client_t* client, const jack_port_t* port);
+
+JACKBRIDGE_API bool jackbridge_port_rename(jack_client_t* client, jack_port_t* port, const char* port_name);
+JACKBRIDGE_API bool jackbridge_port_set_alias(jack_port_t* port, const char* alias);
+JACKBRIDGE_API bool jackbridge_port_unset_alias(jack_port_t* port, const char* alias);
+JACKBRIDGE_API int  jackbridge_port_get_aliases(const jack_port_t* port, char* const al[2]);
+
+JACKBRIDGE_API bool jackbridge_port_request_monitor(jack_port_t* port, bool onoff);
+JACKBRIDGE_API bool jackbridge_port_request_monitor_by_name(jack_client_t* client, const char* port_name, bool onoff);
+JACKBRIDGE_API bool jackbridge_port_ensure_monitor(jack_port_t* port, bool onoff);
+JACKBRIDGE_API bool jackbridge_port_monitoring_input(jack_port_t* port);
+
+JACKBRIDGE_API bool jackbridge_connect(jack_client_t* client, const char* source_port, const char* destination_port);
+JACKBRIDGE_API bool jackbridge_disconnect(jack_client_t* client, const char* source_port, const char* destination_port);
+JACKBRIDGE_API bool jackbridge_port_disconnect(jack_client_t* client, jack_port_t* port);
+
+JACKBRIDGE_API int      jackbridge_port_name_size();
+JACKBRIDGE_API int      jackbridge_port_type_size();
+JACKBRIDGE_API uint32_t jackbridge_port_type_get_buffer_size(jack_client_t* client, const char* port_type);
+
+JACKBRIDGE_API void jackbridge_port_get_latency_range(jack_port_t* port, uint32_t mode, jack_latency_range_t* range);
+JACKBRIDGE_API void jackbridge_port_set_latency_range(jack_port_t* port, uint32_t mode, jack_latency_range_t* range);
+JACKBRIDGE_API bool jackbridge_recompute_total_latencies(jack_client_t* client);
+
+JACKBRIDGE_API const char** jackbridge_get_ports(jack_client_t* client, const char* port_name_pattern, const char* type_name_pattern, uint64_t flags);
+JACKBRIDGE_API jack_port_t* jackbridge_port_by_name(jack_client_t* client, const char* port_name);
+JACKBRIDGE_API jack_port_t* jackbridge_port_by_id(jack_client_t* client, jack_port_id_t port_id);
+
+JACKBRIDGE_API void jackbridge_free(void* ptr);
+
+JACKBRIDGE_API uint32_t jackbridge_midi_get_event_count(void* port_buffer);
+JACKBRIDGE_API bool     jackbridge_midi_event_get(jack_midi_event_t* event, void* port_buffer, uint32_t event_index);
+JACKBRIDGE_API void     jackbridge_midi_clear_buffer(void* port_buffer);
+JACKBRIDGE_API bool     jackbridge_midi_event_write(void* port_buffer, jack_nframes_t time, const jack_midi_data_t* data, uint32_t data_size);
+JACKBRIDGE_API jack_midi_data_t* jackbridge_midi_event_reserve(void* port_buffer, jack_nframes_t time, uint32_t data_size);
+
+JACKBRIDGE_API bool jackbridge_release_timebase(jack_client_t* client);
+JACKBRIDGE_API bool jackbridge_set_sync_callback(jack_client_t* client, JackSyncCallback sync_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_set_sync_timeout(jack_client_t* client, jack_time_t timeout);
+JACKBRIDGE_API bool jackbridge_set_timebase_callback(jack_client_t* client, bool conditional, JackTimebaseCallback timebase_callback, void* arg);
+JACKBRIDGE_API bool jackbridge_transport_locate(jack_client_t* client, jack_nframes_t frame);
+
+JACKBRIDGE_API uint32_t       jackbridge_transport_query(const jack_client_t* client, jack_position_t* pos);
+JACKBRIDGE_API jack_nframes_t jackbridge_get_current_transport_frame(const jack_client_t* client);
+
+JACKBRIDGE_API bool jackbridge_transport_reposition(jack_client_t* client, const jack_position_t* pos);
+JACKBRIDGE_API void jackbridge_transport_start(jack_client_t* client);
+JACKBRIDGE_API void jackbridge_transport_stop(jack_client_t* client);
+
+JACKBRIDGE_API bool jackbridge_set_property(jack_client_t* client, jack_uuid_t subject, const char* key, const char* value, const char* type);
+JACKBRIDGE_API bool jackbridge_get_property(jack_uuid_t subject, const char* key, char** value, char** type);
+JACKBRIDGE_API void jackbridge_free_description(jack_description_t* desc, bool free_description_itself);
+JACKBRIDGE_API bool jackbridge_get_properties(jack_uuid_t subject, jack_description_t* desc);
+JACKBRIDGE_API bool jackbridge_get_all_properties(jack_description_t** descs);
+JACKBRIDGE_API bool jackbridge_remove_property(jack_client_t* client, jack_uuid_t subject, const char* key);
+JACKBRIDGE_API int  jackbridge_remove_properties(jack_client_t* client, jack_uuid_t subject);
+JACKBRIDGE_API bool jackbridge_remove_all_properties(jack_client_t* client);
+JACKBRIDGE_API bool jackbridge_set_property_change_callback(jack_client_t* client, JackPropertyChangeCallback callback, void* arg);
+
+JACKBRIDGE_API bool jackbridge_set_process_thread(jack_client_t* client, JackThreadCallback callback, void* arg);
+JACKBRIDGE_API jack_nframes_t jackbridge_cycle_wait(jack_client_t* client);
+JACKBRIDGE_API void jackbridge_cycle_signal(jack_client_t* client, int status);
+
+JACKBRIDGE_API jack_nframes_t jackbridge_port_get_latency(jack_port_t* port);
+JACKBRIDGE_API jack_nframes_t jackbridge_frame_time(const jack_client_t* client);
+
+// todo
+static inline
+void jackbridge_set_error_function(void* cb) {}
+
+#endif // JACKBRIDGE_HPP_INCLUDED
diff --git a/src/hostapi/jack/pa_jack.c b/src/hostapi/jack/pa_jack.c
index a800f8e..150bf81 100644
--- a/src/hostapi/jack/pa_jack.c
+++ b/src/hostapi/jack/pa_jack.c
@@ -59,8 +59,8 @@
 #include <math.h>
 #include <semaphore.h>
 
-#include <jack/types.h>
-#include <jack/jack.h>
+#include "JackBridge.c"
+#include <pthread.h>
 
 #include "pa_util.h"
 #include "pa_hostapi.h"
@@ -73,7 +73,7 @@
 
 static pthread_t mainThread_;
 static char *jackErr_ = NULL;
-static const char* clientName_ = "PortAudio";
+static const char* clientName_ = "MOD Desktop";
 
 #define STRINGIZE_HELPER(expr) #expr
 #define STRINGIZE(expr) STRINGIZE_HELPER(expr)
@@ -190,16 +190,21 @@ typedef struct PaJackStream
     /* our input and output ports */
     jack_port_t **local_input_ports;
     jack_port_t **local_output_ports;
-
-    /* the input and output ports of the client we are connecting to */
-    jack_port_t **remote_input_ports;
-    jack_port_t **remote_output_ports;
+    jack_port_t *local_input_midi;
+    jack_port_t *local_output_midi;
 
     int num_incoming_connections;
     int num_outgoing_connections;
 
     jack_client_t *jack_client;
 
+    /* MIDI handling */
+    void *midi_get_ptr;
+    void *midi_write_ptr;
+    jacksym_midi_get_event_count midi_get_count;
+    jacksym_midi_event_get midi_get;
+    jacksym_midi_event_write midi_write;
+
     /* The stream is running if it's still producing samples.
      * The stream is active if samples it produced are still being heard.
      */
@@ -232,10 +237,6 @@ typedef struct PaJackStream
 }
 PaJackStream;
 
-/* In calls to jack_get_ports() this filter expression is used instead of ""
- * to prevent any other types (eg Midi ports etc) being listed */
-#define JACK_PORT_TYPE_FILTER "audio"
-
 #define TRUE 1
 #define FALSE 0
 
@@ -468,110 +469,33 @@ static PaError BuildDeviceList( PaJackHostApiRepresentation *jackApi )
     PaError result = paNoError;
     PaUtilHostApiRepresentation *commonApi = &jackApi->commonHostApiRep;
 
-    const char **jack_ports = NULL;
-    char **client_names = NULL;
-    char *regex_pattern = NULL;
-    int port_index, client_index, i;
     double globalSampleRate;
-    regex_t port_regex;
-    unsigned long numClients = 0, numPorts = 0;
-    char *tmp_client_name = NULL;
 
     commonApi->info.defaultInputDevice = paNoDevice;
     commonApi->info.defaultOutputDevice = paNoDevice;
     commonApi->info.deviceCount = 0;
 
-    /* Parse the list of ports, using a regex to grab the client names */
-    ASSERT_CALL( regcomp( &port_regex, "^[^:]*", REG_EXTENDED ), 0 );
-
     /* since we are rebuilding the list of devices, free all memory
      * associated with the previous list */
     PaUtil_FreeAllAllocations( jackApi->deviceInfoMemory );
 
-    regex_pattern = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, jack_client_name_size() + 3 );
-    tmp_client_name = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, jack_client_name_size() );
-
-    /* We can only retrieve the list of clients indirectly, by first
-     * asking for a list of all ports, then parsing the port names
-     * according to the client_name:port_name convention (which is
-     * enforced by jackd)
-     * A: If jack_get_ports returns NULL, there's nothing for us to do */
-    UNLESS( (jack_ports = jack_get_ports( jackApi->jack_client, "", JACK_PORT_TYPE_FILTER, 0 )) && jack_ports[0], paNoError );
-    /* Find number of ports */
-    while( jack_ports[numPorts] )
-        ++numPorts;
-    /* At least there will be one port per client :) */
-    UNLESS( client_names = PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory, numPorts *
-                sizeof (char *) ), paInsufficientMemory );
-
-    /* Build a list of clients from the list of ports */
-    for( numClients = 0, port_index = 0; jack_ports[port_index] != NULL; port_index++ )
-    {
-        int client_seen = FALSE;
-        regmatch_t match_info;
-        const char *port = jack_ports[port_index];
-
-        /* extract the client name from the port name, using a regex
-         * that parses the clientname:portname syntax */
-        UNLESS( !regexec( &port_regex, port, 1, &match_info, 0 ), paInternalError );
-        assert(match_info.rm_eo - match_info.rm_so < jack_client_name_size());
-        memcpy( tmp_client_name, port + match_info.rm_so,
-                match_info.rm_eo - match_info.rm_so );
-        tmp_client_name[match_info.rm_eo - match_info.rm_so] = '\0';
-
-        /* do we know about this port's client yet? */
-        for( i = 0; i < numClients; i++ )
-        {
-            if( strcmp( tmp_client_name, client_names[i] ) == 0 )
-                client_seen = TRUE;
-        }
-
-        if (client_seen)
-            continue;   /* A: Nothing to see here, move along */
-
-        UNLESS( client_names[numClients] = (char*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
-                    strlen(tmp_client_name) + 1), paInsufficientMemory );
-
-        /* The alsa_pcm client should go in spot 0.  If this
-         * is the alsa_pcm client AND we are NOT about to put
-         * it in spot 0 put it in spot 0 and move whatever
-         * was already in spot 0 to the end. */
-        if( strcmp( "alsa_pcm", tmp_client_name ) == 0 && numClients > 0 )
-        {
-            /* alsa_pcm goes in spot 0 */
-            strcpy( client_names[ numClients ], client_names[0] );
-            strcpy( client_names[0], tmp_client_name );
-        }
-        else
-        {
-            /* put the new client at the end of the client list */
-            strcpy( client_names[ numClients ], tmp_client_name );
-        }
-        ++numClients;
-    }
-
-    /* Now we have a list of clients, which will become the list of
-     * PortAudio devices. */
-
     /* there is one global sample rate all clients must conform to */
 
-    globalSampleRate = jack_get_sample_rate( jackApi->jack_client );
+    globalSampleRate = jackbridge_get_sample_rate( jackApi->jack_client );
     UNLESS( commonApi->deviceInfos = (PaDeviceInfo**)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
-                sizeof(PaDeviceInfo*) * numClients ), paInsufficientMemory );
+                sizeof(PaDeviceInfo*) ), paInsufficientMemory );
 
     assert( commonApi->info.deviceCount == 0 );
 
     /* Create a PaDeviceInfo structure for every client */
-    for( client_index = 0; client_index < numClients; client_index++ )
     {
         PaDeviceInfo *curDevInfo;
-        const char **clientPorts = NULL;
 
         UNLESS( curDevInfo = (PaDeviceInfo*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
                     sizeof(PaDeviceInfo) ), paInsufficientMemory );
         UNLESS( curDevInfo->name = (char*)PaUtil_GroupAllocateMemory( jackApi->deviceInfoMemory,
-                    strlen(client_names[client_index]) + 1 ), paInsufficientMemory );
-        strcpy( (char *)curDevInfo->name, client_names[client_index] );
+                    12 ), paInsufficientMemory );
+        strcpy( (char *)curDevInfo->name, "system" );
 
         curDevInfo->structVersion = 2;
         curDevInfo->hostApi = jackApi->hostApiIndex;
@@ -580,65 +504,22 @@ static PaError BuildDeviceList( PaJackHostApiRepresentation *jackApi )
          * system must run at, and all clients must speak IEEE float. */
         curDevInfo->defaultSampleRate = globalSampleRate;
 
-        /* To determine how many input and output channels are available,
-         * we re-query jackd with more specific parameters. */
-
-        sprintf( regex_pattern, "%s:.*", client_names[client_index] );
-
-        /* ... what are your output ports (that we could input from)? */
-        clientPorts = jack_get_ports( jackApi->jack_client, regex_pattern,
-                                     JACK_PORT_TYPE_FILTER, JackPortIsOutput);
-        curDevInfo->maxInputChannels = 0;
+        curDevInfo->maxInputChannels = 2;
         curDevInfo->defaultLowInputLatency = 0.;
         curDevInfo->defaultHighInputLatency = 0.;
-        if( clientPorts )
-        {
-            jack_port_t *p = jack_port_by_name( jackApi->jack_client, clientPorts[0] );
-            curDevInfo->defaultLowInputLatency = curDevInfo->defaultHighInputLatency =
-                jack_port_get_latency( p ) / globalSampleRate;
-
-            for( i = 0; clientPorts[i] != NULL; i++)
-            {
-                /* The number of ports returned is the number of output channels.
-                 * We don't care what they are, we just care how many */
-                curDevInfo->maxInputChannels++;
-            }
-            free(clientPorts);
-        }
 
-        /* ... what are your input ports (that we could output to)? */
-        clientPorts = jack_get_ports( jackApi->jack_client, regex_pattern,
-                                     JACK_PORT_TYPE_FILTER, JackPortIsInput);
-        curDevInfo->maxOutputChannels = 0;
+        curDevInfo->maxOutputChannels = 2;
         curDevInfo->defaultLowOutputLatency = 0.;
         curDevInfo->defaultHighOutputLatency = 0.;
-        if( clientPorts )
-        {
-            jack_port_t *p = jack_port_by_name( jackApi->jack_client, clientPorts[0] );
-            curDevInfo->defaultLowOutputLatency = curDevInfo->defaultHighOutputLatency =
-                jack_port_get_latency( p ) / globalSampleRate;
-
-            for( i = 0; clientPorts[i] != NULL; i++)
-            {
-                /* The number of ports returned is the number of input channels.
-                 * We don't care what they are, we just care how many */
-                curDevInfo->maxOutputChannels++;
-            }
-            free(clientPorts);
-        }
 
         /* Add this client to the list of devices */
-        commonApi->deviceInfos[client_index] = curDevInfo;
-        ++commonApi->info.deviceCount;
-        if( commonApi->info.defaultInputDevice == paNoDevice && curDevInfo->maxInputChannels > 0 )
-            commonApi->info.defaultInputDevice = client_index;
-        if( commonApi->info.defaultOutputDevice == paNoDevice && curDevInfo->maxOutputChannels > 0 )
-            commonApi->info.defaultOutputDevice = client_index;
+        commonApi->deviceInfos[0] = curDevInfo;
+        commonApi->info.deviceCount = 1;
+        commonApi->info.defaultInputDevice = 0;
+        commonApi->info.defaultOutputDevice = 0;
     }
 
 error:
-    regfree( &port_regex );
-    free( jack_ports );
     return result;
 }
 
@@ -730,7 +611,11 @@ PaError PaJack_Initialize( PaUtilHostApiRepresentation **hostApi,
      * automatically which we do not want.
      */
 
-    jackHostApi->jack_client = jack_client_open( clientName_, JackNoStartServer, &jackStatus );
+    if (jackbridge_is_ok())
+        jackHostApi->jack_client = jackbridge_client_open( clientName_, JackNoStartServer, &jackStatus );
+    else
+        jackHostApi->jack_client = NULL;
+
     if( !jackHostApi->jack_client )
     {
         /* the V19 development docs say that if an implementation
@@ -746,7 +631,7 @@ PaError PaJack_Initialize( PaUtilHostApiRepresentation **hostApi,
     *hostApi = &jackHostApi->commonHostApiRep;
     (*hostApi)->info.structVersion = 1;
     (*hostApi)->info.type = paJACK;
-    (*hostApi)->info.name = "JACK Audio Connection Kit";
+    (*hostApi)->info.name = "JACK";
 
     /* Build a device list by querying the JACK server */
     ENSURE_PA( BuildDeviceList( jackHostApi ) );
@@ -778,26 +663,26 @@ PaError PaJack_Initialize( PaUtilHostApiRepresentation **hostApi,
     jackHostApi->processQueue = NULL;
     jackHostApi->jackIsDown = 0;
 
-    jack_on_shutdown( jackHostApi->jack_client, JackOnShutdown, jackHostApi );
-    jack_set_error_function( JackErrorCallback );
-    jackHostApi->jack_buffer_size = jack_get_buffer_size ( jackHostApi->jack_client );
+    jackbridge_on_shutdown( jackHostApi->jack_client, JackOnShutdown, jackHostApi );
+    jackbridge_set_error_function( JackErrorCallback );
+    jackHostApi->jack_buffer_size = jackbridge_get_buffer_size ( jackHostApi->jack_client );
     /* Don't check for error, may not be supported (deprecated in at least jackdmp) */
-    jack_set_sample_rate_callback( jackHostApi->jack_client, JackSrCb, jackHostApi );
-    UNLESS( !jack_set_xrun_callback( jackHostApi->jack_client, JackXRunCb, jackHostApi ), paUnanticipatedHostError );
-    UNLESS( !jack_set_process_callback( jackHostApi->jack_client, JackCallback, jackHostApi ), paUnanticipatedHostError );
-    UNLESS( !jack_activate( jackHostApi->jack_client ), paUnanticipatedHostError );
+    jackbridge_set_sample_rate_callback( jackHostApi->jack_client, JackSrCb, jackHostApi );
+    UNLESS( jackbridge_set_xrun_callback( jackHostApi->jack_client, JackXRunCb, jackHostApi ), paUnanticipatedHostError );
+    UNLESS( jackbridge_set_process_callback( jackHostApi->jack_client, JackCallback, jackHostApi ), paUnanticipatedHostError );
+    UNLESS( jackbridge_activate( jackHostApi->jack_client ), paUnanticipatedHostError );
     activated = 1;
 
     return result;
 
 error:
     if( activated )
-        ASSERT_CALL( jack_deactivate( jackHostApi->jack_client ), 0 );
+        ASSERT_CALL( jackbridge_deactivate( jackHostApi->jack_client ), true );
 
     if( jackHostApi )
     {
         if( jackHostApi->jack_client )
-            ASSERT_CALL( jack_client_close( jackHostApi->jack_client ), 0 );
+            ASSERT_CALL( jackbridge_client_close( jackHostApi->jack_client ), true );
 
         if( jackHostApi->deviceInfoMemory )
         {
@@ -817,12 +702,12 @@ static void Terminate( struct PaUtilHostApiRepresentation *hostApi )
 
     /* note: this automatically disconnects all ports, since a deactivated
      * client is not allowed to have any ports connected */
-    ASSERT_CALL( jack_deactivate( jackHostApi->jack_client ), 0 );
+    ASSERT_CALL( jackbridge_deactivate( jackHostApi->jack_client ), true );
 
     ASSERT_CALL( pthread_mutex_destroy( &jackHostApi->mtx ), 0 );
     ASSERT_CALL( pthread_cond_destroy( &jackHostApi->cond ), 0 );
 
-    ASSERT_CALL( jack_client_close( jackHostApi->jack_client ), 0 );
+    ASSERT_CALL( jackbridge_client_close( jackHostApi->jack_client ), true );
 
     if( jackHostApi->deviceInfoMemory )
     {
@@ -915,7 +800,7 @@ static PaError IsFormatSupported( struct PaUtilHostApiRepresentation *hostApi,
     /* check that the device supports sampleRate */
 
 #define ABS(x) ( (x) > 0 ? (x) : -(x) )
-    if( ABS(sampleRate - jack_get_sample_rate(((PaJackHostApiRepresentation *) hostApi)->jack_client )) > 1 )
+    if( ABS(sampleRate - jackbridge_get_sample_rate(((PaJackHostApiRepresentation *) hostApi)->jack_client )) > 1 )
        return paInvalidSampleRate;
 #undef ABS
 
@@ -940,10 +825,6 @@ static PaError InitializeStream( PaJackStream *stream, PaJackHostApiRepresentati
                 (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numInputChannels ),
                 paInsufficientMemory );
         memset( stream->local_input_ports, 0, sizeof(jack_port_t*) * numInputChannels );
-        UNLESS( stream->remote_output_ports =
-                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numInputChannels ),
-                paInsufficientMemory );
-        memset( stream->remote_output_ports, 0, sizeof(jack_port_t*) * numInputChannels );
     }
     if( numOutputChannels > 0 )
     {
@@ -951,10 +832,6 @@ static PaError InitializeStream( PaJackStream *stream, PaJackHostApiRepresentati
                 (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numOutputChannels ),
                 paInsufficientMemory );
         memset( stream->local_output_ports, 0, sizeof(jack_port_t*) * numOutputChannels );
-        UNLESS( stream->remote_input_ports =
-                (jack_port_t**) PaUtil_GroupAllocateMemory( stream->stream_memory, sizeof(jack_port_t*) * numOutputChannels ),
-                paInsufficientMemory );
-        memset( stream->remote_input_ports, 0, sizeof(jack_port_t*) * numOutputChannels );
     }
 
     stream->num_incoming_connections = numInputChannels;
@@ -980,14 +857,19 @@ static void CleanUpStream( PaJackStream *stream, int terminateStreamRepresentati
     for( i = 0; i < stream->num_incoming_connections; ++i )
     {
         if( stream->local_input_ports[i] )
-            ASSERT_CALL( jack_port_unregister( stream->jack_client, stream->local_input_ports[i] ), 0 );
+            ASSERT_CALL( jackbridge_port_unregister( stream->jack_client, stream->local_input_ports[i] ), 0 );
     }
     for( i = 0; i < stream->num_outgoing_connections; ++i )
     {
         if( stream->local_output_ports[i] )
-            ASSERT_CALL( jack_port_unregister( stream->jack_client, stream->local_output_ports[i] ), 0 );
+            ASSERT_CALL( jackbridge_port_unregister( stream->jack_client, stream->local_output_ports[i] ), 0 );
     }
 
+    if( stream->local_input_midi )
+        ASSERT_CALL( jackbridge_port_unregister( stream->jack_client, stream->local_input_midi ), 0 );
+    if( stream->local_output_midi )
+        ASSERT_CALL( jackbridge_port_unregister( stream->jack_client, stream->local_output_midi ), 0 );
+
     if( terminateStreamRepresentation )
         PaUtil_TerminateStreamRepresentation( &stream->streamRepresentation );
     if( terminateBufferProcessor )
@@ -1077,14 +959,14 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
     PaError result = paNoError;
     PaJackHostApiRepresentation *jackHostApi = (PaJackHostApiRepresentation*)hostApi;
     PaJackStream *stream = NULL;
-    char *port_string = PaUtil_GroupAllocateMemory( jackHostApi->deviceInfoMemory, jack_port_name_size() );
-    unsigned long regexSz = jack_client_name_size() + 3;
+    char *port_string = PaUtil_GroupAllocateMemory( jackHostApi->deviceInfoMemory, jackbridge_port_name_size() );
+    unsigned long regexSz = jackbridge_client_name_size() + 3;
     char *regex_pattern = PaUtil_GroupAllocateMemory( jackHostApi->deviceInfoMemory, regexSz );
     const char **jack_ports = NULL;
-    /* int jack_max_buffer_size = jack_get_buffer_size( jackHostApi->jack_client ); */
+    /* int jack_max_buffer_size = jackbridge_get_buffer_size( jackHostApi->jack_client ); */
     int i;
     int inputChannelCount, outputChannelCount;
-    const double jackSr = jack_get_sample_rate( jackHostApi->jack_client );
+    const double jackSr = jackbridge_get_sample_rate( jackHostApi->jack_client );
     PaSampleFormat inputSampleFormat = 0, outputSampleFormat = 0;
     int bpInitialized = 0, srInitialized = 0;   /* Initialized buffer processor and stream representation? */
     unsigned long ofs;
@@ -1178,7 +1060,7 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
             latency = outputParameters->suggestedLatency;
 
         /* the latency the user asked for indicates the minimum buffer size in frames */
-        minimum_buffer_frames = (int) (latency * jack_get_sample_rate( jackHostApi->jack_client ));
+        minimum_buffer_frames = (int) (latency * jackbridge_get_sample_rate( jackHostApi->jack_client ));
 
         /* we also need to be able to store at least three full jack buffers to avoid dropouts */
         if( jackHostApi->jack_buffer_size * 3 > minimum_buffer_frames )
@@ -1211,8 +1093,8 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
     ofs = jackHostApi->inputBase;
     for( i = 0; i < inputChannelCount; i++ )
     {
-        snprintf( port_string, jack_port_name_size(), "in_%lu", ofs + i );
-        UNLESS( stream->local_input_ports[i] = jack_port_register(
+        snprintf( port_string, jackbridge_port_name_size(), "audio-in-%lu", ofs + i + 1 );
+        UNLESS( stream->local_input_ports[i] = jackbridge_port_register(
               jackHostApi->jack_client, port_string,
               JACK_DEFAULT_AUDIO_TYPE, JackPortIsInput, 0 ), paInsufficientMemory );
     }
@@ -1221,64 +1103,19 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
     ofs = jackHostApi->outputBase;
     for( i = 0; i < outputChannelCount; i++ )
     {
-        snprintf( port_string, jack_port_name_size(), "out_%lu", ofs + i );
-        UNLESS( stream->local_output_ports[i] = jack_port_register(
+        snprintf( port_string, jackbridge_port_name_size(), "audio-out-%lu", ofs + i + 1 );
+        UNLESS( stream->local_output_ports[i] = jackbridge_port_register(
              jackHostApi->jack_client, port_string,
              JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0 ), paInsufficientMemory );
     }
     jackHostApi->outputBase += outputChannelCount;
 
-    /* look up the jack_port_t's for the remote ports.  We could do
-     * this at stream start time, but doing it here ensures the
-     * name lookup only happens once. */
-
-    if( inputChannelCount > 0 )
-    {
-        int err = 0;
-
-        /* Get output ports of our capture device */
-        snprintf( regex_pattern, regexSz, "%s:.*", hostApi->deviceInfos[ inputParameters->device ]->name );
-        UNLESS( jack_ports = jack_get_ports( jackHostApi->jack_client, regex_pattern,
-                                     JACK_PORT_TYPE_FILTER, JackPortIsOutput ), paUnanticipatedHostError );
-        for( i = 0; i < inputChannelCount && jack_ports[i]; i++ )
-        {
-            if( (stream->remote_output_ports[i] = jack_port_by_name(
-                 jackHostApi->jack_client, jack_ports[i] )) == NULL )
-            {
-                err = 1;
-                break;
-            }
-        }
-        free( jack_ports );
-        UNLESS( !err, paInsufficientMemory );
-
-        /* Fewer ports than expected? */
-        UNLESS( i == inputChannelCount, paInternalError );
-    }
-
-    if( outputChannelCount > 0 )
-    {
-        int err = 0;
-
-        /* Get input ports of our playback device */
-        snprintf( regex_pattern, regexSz, "%s:.*", hostApi->deviceInfos[ outputParameters->device ]->name );
-        UNLESS( jack_ports = jack_get_ports( jackHostApi->jack_client, regex_pattern,
-                                     JACK_PORT_TYPE_FILTER, JackPortIsInput ), paUnanticipatedHostError );
-        for( i = 0; i < outputChannelCount && jack_ports[i]; i++ )
-        {
-            if( (stream->remote_input_ports[i] = jack_port_by_name(
-                 jackHostApi->jack_client, jack_ports[i] )) == 0 )
-            {
-                err = 1;
-                break;
-            }
-        }
-        free( jack_ports );
-        UNLESS( !err , paInsufficientMemory );
-
-        /* Fewer ports than expected? */
-        UNLESS( i == outputChannelCount, paInternalError );
-    }
+    UNLESS( stream->local_input_midi = jackbridge_port_register(
+            jackHostApi->jack_client, "midi-in",
+            JACK_DEFAULT_MIDI_TYPE, JackPortIsInput, 0 ), paInsufficientMemory );
+    UNLESS( stream->local_output_midi = jackbridge_port_register(
+            jackHostApi->jack_client, "midi-out",
+            JACK_DEFAULT_MIDI_TYPE, JackPortIsOutput, 0 ), paInsufficientMemory );
 
     ENSURE_PA( PaUtil_InitializeBufferProcessor(
                   &stream->bufferProcessor,
@@ -1298,16 +1135,14 @@ static PaError OpenStream( struct PaUtilHostApiRepresentation *hostApi,
     bpInitialized = 1;
 
     if( stream->num_incoming_connections > 0 )
-        stream->streamRepresentation.streamInfo.inputLatency = (jack_port_get_latency( stream->remote_output_ports[0] )
-                - jack_get_buffer_size( jackHostApi->jack_client )  /* One buffer is not counted as latency */
-            + PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor )) / sampleRate;
+        stream->streamRepresentation.streamInfo.inputLatency =
+            PaUtil_GetBufferProcessorInputLatencyFrames( &stream->bufferProcessor ) / sampleRate;
     if( stream->num_outgoing_connections > 0 )
-        stream->streamRepresentation.streamInfo.outputLatency = (jack_port_get_latency( stream->remote_input_ports[0] )
-                - jack_get_buffer_size( jackHostApi->jack_client )  /* One buffer is not counted as latency */
-            + PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor )) / sampleRate;
+        stream->streamRepresentation.streamInfo.outputLatency =
+            PaUtil_GetBufferProcessorOutputLatencyFrames( &stream->bufferProcessor ) / sampleRate;
 
     stream->streamRepresentation.streamInfo.sampleRate = jackSr;
-    stream->t0 = jack_frame_time( jackHostApi->jack_client );   /* A: Time should run from Pa_OpenStream */
+    stream->t0 = jackbridge_frame_time( jackHostApi->jack_client );   /* A: Time should run from Pa_OpenStream */
 
     /* Add to queue of opened streams */
     ENSURE_PA( AddStream( stream ) );
@@ -1346,7 +1181,10 @@ static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
     PaStreamCallbackTimeInfo timeInfo = {0,0,0};
     int chn;
     int framesProcessed;
-    const double sr = jack_get_sample_rate( stream->jack_client );    /* Shouldn't change during the process callback */
+    void *mbuf;
+    uint32_t num_events;
+    jack_midi_event_t event;
+    const double sr = jackbridge_get_sample_rate( stream->jack_client );    /* Shouldn't change during the process callback */
     PaStreamCallbackFlags cbFlags = 0;
 
     /* If the user has returned !paContinue from the callback we'll want to flush the internal buffers,
@@ -1362,13 +1200,11 @@ static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
         goto end;
     }
 
-    timeInfo.currentTime = (jack_frame_time( stream->jack_client ) - stream->t0) / sr;
+    timeInfo.currentTime = (jackbridge_frame_time( stream->jack_client ) - stream->t0) / sr;
     if( stream->num_incoming_connections > 0 )
-        timeInfo.inputBufferAdcTime = timeInfo.currentTime - jack_port_get_latency( stream->remote_output_ports[0] )
-            / sr;
+        timeInfo.inputBufferAdcTime = timeInfo.currentTime;
     if( stream->num_outgoing_connections > 0 )
-        timeInfo.outputBufferDacTime = timeInfo.currentTime + jack_port_get_latency( stream->remote_input_ports[0] )
-            / sr;
+        timeInfo.outputBufferDacTime = timeInfo.currentTime;
 
     PaUtil_BeginCpuLoadMeasurement( &stream->cpuLoadMeasurer );
 
@@ -1389,7 +1225,7 @@ static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
     for( chn = 0; chn < stream->num_incoming_connections; chn++ )
     {
         jack_default_audio_sample_t *channel_buf = (jack_default_audio_sample_t*)
-            jack_port_get_buffer( stream->local_input_ports[chn],
+            jackbridge_port_get_buffer( stream->local_input_ports[chn],
                     frames );
 
         PaUtil_SetNonInterleavedInputChannel( &stream->bufferProcessor,
@@ -1400,7 +1236,7 @@ static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
     for( chn = 0; chn < stream->num_outgoing_connections; chn++ )
     {
         jack_default_audio_sample_t *channel_buf = (jack_default_audio_sample_t*)
-            jack_port_get_buffer( stream->local_output_ports[chn],
+            jackbridge_port_get_buffer( stream->local_output_ports[chn],
                     frames );
 
         PaUtil_SetNonInterleavedOutputChannel( &stream->bufferProcessor,
@@ -1408,11 +1244,41 @@ static PaError RealProcess( PaJackStream *stream, jack_nframes_t frames )
                 channel_buf );
     }
 
+    if( stream->midi_write_ptr )
+    {
+        mbuf = jackbridge_port_get_buffer( stream->local_input_midi, frames );
+        num_events = jackbridge_midi_get_event_count (mbuf);
+
+        for (uint32_t i = 0; i < num_events; ++i)
+        {
+            if( !jackbridge_midi_event_get( &event, mbuf, i ) )
+                break;
+
+            stream->midi_write( stream->midi_write_ptr, event.time, event.buffer, event.size );
+        }
+    }
+
     framesProcessed = PaUtil_EndBufferProcessing( &stream->bufferProcessor,
             &stream->callbackResult );
     /* We've specified a host buffer size mode where every frame should be consumed by the buffer processor */
     assert( framesProcessed == frames );
 
+    mbuf = jackbridge_port_get_buffer( stream->local_output_midi, frames );
+    jackbridge_midi_clear_buffer (mbuf);
+
+    if( stream->midi_get_ptr )
+    {
+        num_events = stream->midi_get_count( stream->midi_get_ptr );
+
+        for (uint32_t i = 0; i < num_events; ++i)
+        {
+            if( stream->midi_get( &event, stream->midi_get_ptr, i ) != 0 )
+                break;
+
+            jackbridge_midi_event_write( mbuf, event.time, event.buffer, event.size );
+        }
+    }
+
     PaUtil_EndCpuLoadMeasurement( &stream->cpuLoadMeasurer, framesProcessed );
 
 end:
@@ -1424,7 +1290,7 @@ static PaError UpdateQueue( PaJackHostApiRepresentation *hostApi )
 {
     PaError result = paNoError;
     int queueModified = 0;
-    const double jackSr = jack_get_sample_rate( hostApi->jack_client );
+    const double jackSr = jackbridge_get_sample_rate( hostApi->jack_client );
     int err;
 
     if( (err = pthread_mutex_trylock( &hostApi->mtx )) != 0 )
@@ -1559,7 +1425,7 @@ static int JackCallback( jack_nframes_t frames, void *userData )
             PA_DEBUG(( "Silencing the output\n" ));
             for( i = 0; i < stream->num_outgoing_connections; ++i )
             {
-                jack_default_audio_sample_t *buffer = jack_port_get_buffer( stream->local_output_ports[i], frames );
+                jack_default_audio_sample_t *buffer = jackbridge_port_get_buffer( stream->local_output_ports[i], frames );
                 memset( buffer, 0, sizeof (jack_default_audio_sample_t) * frames );
             }
 
@@ -1602,24 +1468,24 @@ static PaError StartStream( PaStream *s )
     /* Connect the ports. Note that the ports may already have been connected by someone else in
      * the meantime, in which case JACK returns EEXIST. */
 
-    if( stream->num_incoming_connections > 0 )
+    if( stream->num_incoming_connections == 2 )
     {
-        for( i = 0; i < stream->num_incoming_connections; i++ )
-        {
-            int r = jack_connect( stream->jack_client, jack_port_name( stream->remote_output_ports[i] ),
-                    jack_port_name( stream->local_input_ports[i] ) );
-           UNLESS( 0 == r || EEXIST == r, paUnanticipatedHostError );
-        }
+        jackbridge_connect( stream->jack_client, "system:capture_1",
+                            jackbridge_port_name( stream->local_input_ports[0] ) );
+
+        jackbridge_connect( stream->jack_client, "system:capture_2",
+                            jackbridge_port_name( stream->local_input_ports[1] ) );
     }
 
-    if( stream->num_outgoing_connections > 0 )
+    if( stream->num_outgoing_connections == 2 )
     {
-        for( i = 0; i < stream->num_outgoing_connections; i++ )
-        {
-            int r = jack_connect( stream->jack_client, jack_port_name( stream->local_output_ports[i] ),
-                    jack_port_name( stream->remote_input_ports[i] ) );
-           UNLESS( 0 == r || EEXIST == r, paUnanticipatedHostError );
-        }
+        jackbridge_connect( stream->jack_client,
+                            jackbridge_port_name( stream->local_output_ports[0] ),
+                            "system:playback_1" );
+
+        jackbridge_connect( stream->jack_client,
+                            jackbridge_port_name( stream->local_output_ports[1] ),
+                            "system:playback_2" );
     }
 
     stream->xrun = FALSE;
@@ -1685,17 +1551,17 @@ error:
     {
         for( i = 0; i < stream->num_incoming_connections; i++ )
         {
-            if( jack_port_connected( stream->local_input_ports[i] ) )
+            if( jackbridge_port_connected( stream->local_input_ports[i] ) )
             {
-                UNLESS( !jack_port_disconnect( stream->jack_client, stream->local_input_ports[i] ),
+                UNLESS( jackbridge_port_disconnect( stream->jack_client, stream->local_input_ports[i] ),
                         paUnanticipatedHostError );
             }
         }
         for( i = 0; i < stream->num_outgoing_connections; i++ )
         {
-            if( jack_port_connected( stream->local_output_ports[i] ) )
+            if( jackbridge_port_connected( stream->local_output_ports[i] ) )
             {
-                UNLESS( !jack_port_disconnect( stream->jack_client, stream->local_output_ports[i] ),
+                UNLESS( jackbridge_port_disconnect( stream->jack_client, stream->local_output_ports[i] ),
                         paUnanticipatedHostError );
             }
         }
@@ -1735,7 +1601,7 @@ static PaTime GetStreamTime( PaStream *s )
     PaJackStream *stream = (PaJackStream*)s;
 
     /* A: Is this relevant?? --> TODO: what if we're recording-only? */
-    return (jack_frame_time( stream->jack_client ) - stream->t0) / (PaTime)jack_get_sample_rate( stream->jack_client );
+    return (jackbridge_frame_time( stream->jack_client ) - stream->t0) / (PaTime)jackbridge_get_sample_rate( stream->jack_client );
 }
 
 
@@ -1747,7 +1613,7 @@ static double GetStreamCpuLoad( PaStream* s )
 
 PaError PaJack_SetClientName( const char* name )
 {
-    if( strlen( name ) > jack_client_name_size() )
+    if( strlen( name ) > jackbridge_client_name_size() )
     {
         /* OK, I don't know any better error code */
         return paInvalidFlag;
@@ -1756,13 +1622,35 @@ PaError PaJack_SetClientName( const char* name )
     return paNoError;
 }
 
+void PaJack_SetMidiCallbacks( PaStream *s,
+                              jacksym_midi_get_event_count get_count,
+                              jacksym_midi_event_get get,
+                              jacksym_midi_event_write write )
+{
+    PaJackStream *stream = (PaJackStream*)s;
+
+    stream->midi_get_count = get_count;
+    stream->midi_get = get;
+    stream->midi_write = write;
+}
+
+void PaJack_SetMidiBuffers( PaStream *s,
+                            void* get_ptr,
+                            void* write_ptr )
+{
+    PaJackStream *stream = (PaJackStream*)s;
+
+    stream->midi_get_ptr = get_ptr;
+    stream->midi_write_ptr = write_ptr;
+}
+
 PaError PaJack_GetClientName(const char** clientName)
 {
     PaError result = paNoError;
     PaJackHostApiRepresentation* jackHostApi = NULL;
     PaJackHostApiRepresentation** ref = &jackHostApi;
     ENSURE_PA( PaUtil_GetHostApiRepresentation( (PaUtilHostApiRepresentation**)ref, paJACK ) );
-    *clientName = jack_get_client_name( jackHostApi->jack_client );
+    *clientName = jackbridge_get_client_name( jackHostApi->jack_client );
 
 error:
     return result;
